<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>lp_solve 5.5 Java Wrapper - Function Reference</title>
<style type="text/css">
<!--
body  { font-family: Verdana, Arial, Helvetica, sans-serif; }
td,th	{ text-align:left; }
li		{ margin-top: 3px; }
pre		{ font-size: smaller; }
-->
</style>

</head>

<body>

<h1>Using lp_solve 5.5 in Java programs</h1>

<h2>C - Java function reference</h2>

<p>This file contains a reference for all methods in the lp_solve library and the Java wrapper.
The first column of the following table contains the C functions of the lp_solve library,
the second column the corresponding methods of the Java wrapper.</p>


<table border="1">
<tr><th>C function</th><th>Java wrapper method (LpSolve class)</th></tr>
<tr><td>unsigned char add_column (lprec* lp, REAL* column)</td><td>void addColumn(double[] column) throws LpSolveException</td></tr>
<tr><td>unsigned char add_columnex (lprec* lp, int count, REAL* column, int* rowno)</td><td>void addColumnex(int count, double[] column, int[] rowno) throws LpSolveException</td></tr>
<tr><td>unsigned char add_constraint (lprec* lp, REAL *row, int constr_type, REAL rh)</td><td>void addConstraint(double[] row, int constrType, double rh) throws LpSolveException</td></tr>
<tr><td>unsigned char add_constraintex (lprec *lp, int count, REAL *row, int *colno, int constr_type, REAL rh)</td><td>void addConstraintex(int count, double[] row, int[] colno, int constrType, double rh) throws LpSolveException</td></tr>
<tr><td>unsigned char add_lag_con (lprec* lp, REAL *row, int con_type, REAL rhs)</td><td>void addLagCon(double[] row, int constrType, double rh) throws LpSolveException</td></tr>
<tr><td>int add_SOS (lprec* lp, char *name, int sostype, int priority, int count, int *sosvars, REAL *weights)</td><td>void addSOS(String name, int sostype, int priority, int count, int[] sosvars, double[] weights) throws LpSolveException</td></tr>
<tr><td>int column_in_lp (lprec* lp, REAL *column)</td><td>int columnInLp(double[] column)</td></tr>
<tr><td>void default_basis (lprec* lp)</td><td>void defaultBasis()</td></tr>
<tr><td>unsigned char del_column(lprec *lp, int column)</td><td>void delColumn(int columnnr) throws LpSolveException</td></tr>
<tr><td>unsigned char del_constraint(lprec *lp, int del_row)</td><td>void delConstraint(int rownr) throws LpSolveException</td></tr>
<tr><td>void delete_lp(lprec *lp)</td><td>void deleteLp()</td></tr>
<tr><td>void free_lp(lprec **plp)</td><td><strong>&lt;Not implemented, use deleteLp() instead&gt;</strong></td></tr>
<tr><td>int get_anti_degen(lprec *lp)</td><td>int getAntiDegen()</td></tr>
<tr><td>void get_basis(lprec *lp, int *bascolumn, unsigned char nonbasic)</td><td>void getBasis(int[] bascolumn, boolean nonbasic)</td></tr>
<tr><td>int get_basiscrash(lprec *lp)</td><td>int getBasiscrash()</td></tr>
<tr><td>int get_bb_depthlimit(lprec *lp)</td><td>int getBbDepthlimit()</td></tr>
<tr><td>int get_bb_floorfirst(lprec *lp)</td><td>int getBbFloorfirst()</td></tr>
<tr><td>int get_bb_rule(lprec *lp)</td><td>int getBbRule()</td></tr>
<tr><td>unsigned char get_bounds_tighter(lprec *lp)</td><td>boolean getBoundsTighter()</td></tr>
<tr><td>REAL get_break_at_value(lprec *lp)</td><td>double getBreakAtValue()</td></tr>
<tr><td>char *get_col_name(lprec *lp, int column)</td><td>String getColName(int colnr) throws LpSolveException</td></tr>
<tr><td>unsigned char get_column(lprec *lp, int col_nr, REAL *column)</td><td>void getColumn(int columnrnr, double[] column) throws LpSolveException</td></tr>
<tr><td><strong>&lt;Not implemented&gt;</strong></td><td>double[] getPtrColumn(int columnrnr) throws LpSolveException</td></tr>
<tr><td>int get_constr_type(lprec *lp, int row)</td><td>short getConstrType(int rownr) throws LpSolveException</td></tr>
<tr><td>unsigned char get_constraints(lprec *lp, REAL *constr)</td><td>void getConstraints(double[] var) throws LpSolveException</td></tr>
<tr><td>unsigned char get_dual_solution(lprec *lp, REAL *duals)</td><td>void getDualSolution(double[] duals) throws LpSolveException</td></tr>
<tr><td>REAL get_epsb(lprec *lp)</td><td>double getEpsb()</td></tr>
<tr><td>REAL get_epsd(lprec *lp)</td><td>double getEpsd()</td></tr>
<tr><td>REAL get_epsel(lprec *lp)</td><td>double getEpsel()</td></tr>
<tr><td>REAL get_epsint(lprec *lp)</td><td>double getEpsint()</td></tr>
<tr><td>REAL get_epsperturb(lprec *lp)</td><td>double getEpsperturb()</td></tr>
<tr><td>REAL get_epspivot(lprec *lp)</td><td>double getEpspivot()</td></tr>
<tr><td>int get_improve(lprec *lp)</td><td>int getImprove()</td></tr>
<tr><td>REAL get_infinite(lprec *lp)</td><td>double getInfinite()</td></tr>
<tr><td>unsigned char get_lambda(lprec *lp, REAL *lambda)</td><td>void getLambda(double[] lambda) throws LpSolveException</td></tr>
<tr><td>REAL get_lowbo(lprec *lp, int column)</td><td>double getLowbo(int colnr) throws LpSolveException</td></tr>
<tr><td>int get_lp_index(lprec *lp, int orig_index)</td><td>int getLpIndex(int index)</td></tr>
<tr><td>char *get_lp_name(lprec *lp)</td><td>String getLpName() throws LpSolveException</td></tr>
<tr><td>int get_Lrows(lprec *lp)</td><td>int getLrows()</td></tr>
<tr><td>REAL get_mat(lprec *lp, int row, int column)</td><td>double getMat(int row, int column)</td></tr>
<tr><td>int get_max_level(lprec *lp)</td><td>int getMaxLevel()</td></tr>
<tr><td>int get_maxpivot(lprec *lp)</td><td>int getMaxpivot()</td></tr>
<tr><td>REAL get_mip_gap(lprec *lp, unsigned char absolute)</td><td>double getMipGap(boolean absolute)</td></tr>
<tr><td>int get_Ncolumns(lprec *lp)</td><td>int getNcolumns()</td></tr>
<tr><td>REAL get_negrange(lprec *lp)</td><td>double getNegrange()</td></tr>
<tr><td>int get_nonzeros(lprec *lp)</td><td>int getNonzeros()</td></tr>
<tr><td>int get_Norig_columns(lprec *lp)</td><td>int getNorigColumns()</td></tr>
<tr><td>int get_Norig_rows(lprec *lp)</td><td>int getNorigRows()</td></tr>
<tr><td>int get_Nrows(lprec *lp)</td><td>int getNrows()</td></tr>
<tr><td>REAL get_obj_bound(lprec *lp)</td><td>double getObjBound()</td></tr>
<tr><td>REAL get_objective(lprec *lp)</td><td>getObjective()</td></tr>
<tr><td>int get_orig_index(lprec *lp, int lp_index)</td><td>int getOrigIndex(int index)</td></tr>
<tr><td>char *get_origcol_name(lprec *lp, int column)</td><td>String getOrigcolName(int colnr) throws LpSolveException</td></tr>
<tr><td>char *get_origrow_name(lprec *lp, int row)</td><td>String getOrigrowName(int rownr) throws LpSolveException</td></tr>
<tr><td>int get_pivoting(lprec *lp)</td><td>int getPivoting()</td></tr>
<tr><td>int get_presolve(lprec *lp)</td><td>int getPresolve()</td></tr>
<tr><td>unsigned char get_primal_solution(lprec *lp, REAL *pv)</td><td>void getPrimalSolution(double[] pv) throws LpSolveException</td></tr>
<tr><td>int get_print_sol(lprec *lp)</td><td>int getPrintSol()</td></tr>
<tr><td>unsigned char get_ptr_constraints(lprec *lp, REAL **ptr_constr)</td><td>double[] getPtrConstraints() throws LpSolveException</td></tr>
<tr><td>unsigned char get_ptr_dual_solution(lprec *lp, REAL **ptr_duals)</td><td>double[] getPtrDualSolution() throws LpSolveException</td></tr>
<tr><td>unsigned char get_ptr_lambda(lprec *lp, REAL **ptr_lambda)</td><td>double[] getPtrLambda() throws LpSolveException</td></tr>
<tr><td>unsigned char get_ptr_primal_solution(lprec *lp, REAL **ptr_pv)</td><td>double[] getPtrPrimalSolution() throws LpSolveException</td></tr>
<tr><td>unsigned char get_ptr_sensitivity_obj(lprec *lp, REAL **ptr_objfrom, REAL **ptr_objtill)</td><td>double[][] getPtrSensitivityObj() throws LpSolveException</td></tr>
<tr><td>unsigned char get_ptr_sensitivity_objex(lprec *lp, REAL **ptr_objfrom, REAL **ptr_objtill, REAL *ptr_objfromvalue, REAL *ptr_objtillvalue)</td><td>double[][] getPtrSensitivityObjex() throws LpSolveException</td></tr>
<tr><td>unsigned char get_ptr_sensitivity_rhs(lprec *lp, REAL **ptr_duals, REAL **ptr_dualsfrom, REAL **ptr_dualstill)</td><td>double[][] getPtrSensitivityRhs() throws LpSolveException</td></tr>
<tr><td>unsigned char get_ptr_variables(lprec *lp, REAL **ptr_var)</td><td>double[] getPtrVariables() throws LpSolveException</td></tr>
<tr><td>REAL get_rh(lprec *lp, int row)</td><td>double getRh(int row)</td></tr>
<tr><td>REAL get_rh_range(lprec *lp, int row)</td><td>double getRhRange(int rownr) throws LpSolveException</td></tr>
<tr><td>unsigned char get_row(lprec *lp, int row_nr, REAL *row)</td><td>void getRow(int rownr, double[] row) throws LpSolveException</td></tr>
<tr><td><strong>&lt;Not implemented&gt;</strong></td><td>double[] getPtrRow(int rownr) throws LpSolveException</td></tr>
<tr><td>char *get_row_name(lprec *lp, int row)</td><td>String getRowName(int rownr) throws LpSolveException</td></tr>
<tr><td>REAL get_scalelimit(lprec *lp)</td><td>double getScalelimit()</td></tr>
<tr><td>int get_scaling(lprec *lp)</td><td>int getScaling()</td></tr>
<tr><td>unsigned char get_sensitivity_obj(lprec *lp, REAL *objfrom, REAL *objtill)</td><td>void getSensitivityObj(double[] objfrom, double[] objtill) throws LpSolveException</td></tr>
<tr><td>unsigned char get_sensitivity_objex(lprec *lp, REAL *objfrom, REAL *objtill, REAL *objfromvalue, REAL *objtillvalue)</td><td>void getSensitivityObjex(double[] objfrom, double[] objtill, double[] objfromvalue, double[] objtillvalue) throws LpSolveException</td></tr>
<tr><td>unsigned char get_sensitivity_rhs(lprec *lp, REAL *duals, REAL *dualsfrom, REAL *dualstill)</td><td>void getSensitivityRhs(double[] duals, double[] dualsfrom, double[] dualstill) throws LpSolveException</td></tr>
<tr><td>int get_simplextype(lprec *lp)</td><td>int getSimplextype()</td></tr>
<tr><td>int get_solutioncount(lprec *lp)</td><td>int getSolutioncount()</td></tr>
<tr><td>int get_solutionlimit(lprec *lp)</td><td>int getSolutionlimit()</td></tr>
<tr><td>int get_status(lprec *lp)</td><td>int getStatus()</td></tr>
<tr><td>char *get_statustext(lprec *lp, int statuscode)</td><td>String getStatustext(int statuscode)</td></tr>
<tr><td>long get_timeout(lprec *lp)</td><td>long getTimeout()</td></tr>
<tr><td>int get_total_iter(lprec *lp)</td><td>int getTotalIter()</td></tr>
<tr><td>int get_total_nodes(lprec *lp)</td><td>int getTotalNodes()</td></tr>
<tr><td>REAL get_upbo(lprec *lp, int column)</td><td>double getUpbo(int colnr) throws LpSolveException</td></tr>
<tr><td>int get_var_branch(lprec *lp, int column)</td><td>int getVarBranch(int colnr) throws LpSolveException</td></tr>
<tr><td>REAL get_var_dualresult(lprec *lp, int index)</td><td>double getVarDualresult(int index) throws LpSolveException</td></tr>
<tr><td>REAL get_var_primalresult(lprec *lp, int index)</td><td>double getVarPrimalresult(int index) throws LpSolveException</td></tr>
<tr><td>int get_var_priority(lprec *lp, int column)</td><td>int getVarPriority(int colnr) throws LpSolveException</td></tr>
<tr><td>unsigned char get_variables(lprec *lp, REAL *var)</td><td>void getVariables(double[] var) throws LpSolveException</td></tr>
<tr><td>int get_verbose(lprec *lp)</td><td>int getVerbose()</td></tr>
<tr><td>REAL get_working_objective(lprec *lp)</td><td>double getWorkingObjective() throws LpSolveException</td></tr>
<tr><td>unsigned char guess_basis(lprec *lp, double *guessvector, int *basisvector)</td><td>void guessBasis(double[] guessvector, int[] basisvector) throws LpSolveException</td></tr>
<tr><td>unsigned char has_BFP(lprec *lp)</td><td>boolean hasBFP()</td></tr>
<tr><td>unsigned char has_XLI(lprec *lp)</td><td>boolean hasXLI()</td></tr>
<tr><td>unsigned char is_add_rowmode(lprec *lp)</td><td>boolean isAddRowmode()</td></tr>
<tr><td>unsigned char is_anti_degen(lprec *lp, int testmask)</td><td>boolean isAntiDegen(int testmask)</td></tr>
<tr><td>unsigned char is_binary(lprec *lp, int column)</td><td>boolean isBinary(int colnr)</td></tr>
<tr><td>unsigned char is_break_at_first(lprec *lp)</td><td>boolean isBreakAtFirst()</td></tr>
<tr><td>unsigned char is_constr_type(lprec *lp, int row, int mask)</td><td>boolean isConstrType(int row, int mask)</td></tr>
<tr><td>unsigned char is_debug(lprec *lp)</td><td>boolean isDebug()</td></tr>
<tr><td>unsigned char is_feasible(lprec *lp, REAL *values, REAL threshold)</td><td>boolean isFeasible(double[] values, double threshold) throws LpSolveException</td></tr>
<tr><td>unsigned char is_free(lprec *lp, int column)</td><td>boolean isFree(int colnr)</td></tr>
<tr><td>unsigned char is_infinite(lprec *lp, REAL value)</td><td>boolean isInfinite(double value)</td></tr>
<tr><td>unsigned char is_int(lprec *lp, int column)</td><td>boolean isInt(int colnr)</td></tr>
<tr><td>unsigned char is_integerscaling(lprec *lp)</td><td>boolean isIntegerscaling()</td></tr>
<tr><td>unsigned char is_lag_trace(lprec *lp)</td><td>boolean isLagTrace()</td></tr>
<tr><td>unsigned char is_maxim(lprec *lp)</td><td>boolean isMaxim()</td></tr>
<tr><td>unsigned char is_nativeBFP(lprec *lp)</td><td>boolean isNativeBFP()</td></tr>
<tr><td>unsigned char is_nativeXLI(lprec *lp)</td><td>boolean isNativeXLI()</td></tr>
<tr><td>unsigned char is_negative(lprec *lp, int column)</td><td>boolean isNegative(int colnr)</td></tr>
<tr><td>unsigned char is_piv_mode(lprec *lp, int testmask)</td><td>boolean isPivMode(int testmask)</td></tr>
<tr><td>unsigned char is_piv_rule(lprec *lp, int rule)</td><td>boolean isPivRule(int rule)</td></tr>
<tr><td>unsigned char is_presolve(lprec *lp, int testmask)</td><td>boolean isPresolve(int testmask)</td></tr>
<tr><td>unsigned char is_scalemode(lprec *lp, int testmask)</td><td>boolean isScalemode(int testmask)</td></tr>
<tr><td>unsigned char is_scaletype(lprec *lp, int scaletype)</td><td>boolean isScaletype(int scaletype)</td></tr>
<tr><td>unsigned char is_semicont(lprec *lp, int column)</td><td>boolean isSemicont(int colnr)</td></tr>
<tr><td>unsigned char is_SOS_var(lprec *lp, int column)</td><td>boolean isSOSVar(int colnr) throws LpSolveException</td></tr>
<tr><td>unsigned char is_trace(lprec *lp)</td><td>boolean isTrace()</td></tr>
<tr><td>int lag_solve(lprec *lp, REAL start_bound, int num_iter, short verbose)</td><td><strong>&lt;Function is currently not exported from lp_solve dll&gt;</strong></td></tr>
<tr><td>void lp_solve_version(int *majorversion, int *minorversion, int *release, int *build)</td><td>static VersionInfo lpSolveVersion()</td></tr>
<tr><td>lprec *make_lp(int rows, int columns)</td><td>static LpSolve makeLp(int rows, int columns) throws LpSolveException</td></tr>
<tr><td>void print_constraints(lprec *lp, int columns)</td><td>void printConstraints(int columns)</td></tr>
<tr><td>unsigned char print_debugdump(lprec *lp, char *filename)</td><td>void printDebugdump(String filename) throws LpSolveException</td></tr>
<tr><td>void print_duals(lprec *lp)</td><td>void printDuals()</td></tr>
<tr><td>void print_lp(lprec *lp)</td><td>void printLp()</td></tr>
<tr><td>void print_objective(lprec *lp)</td><td>void printObjective()</td></tr>
<tr><td>void print_scales(lprec *lp)</td><td>void printScales()</td></tr>
<tr><td>void print_solution(lprec *lp, int columns)</td><td>void printSolution(int columns)</td></tr>
<tr><td>void print_str(lprec *lp, char *str)</td><td>void printStr(String str)</td></tr>
<tr><td>void print_tableau(lprec *lp)</td><td>void printTableau()</td></tr>
<tr><td>void put_abortfunc(lprec *lp, ctrlcfunc newctrlc, void *ctrlchandle)</td><td>void putAbortfunc(AbortListener listener, Object userhandle) throws LpSolveException</td></tr>
<tr><td>void put_logfunc(lprec *lp, logfunc newlog, void *loghandle)</td><td>void putLogfunc(LogListener listener, Object userhandle) throws LpSolveException</td></tr>
<tr><td>void put_msgfunc(lprec *lp, msgfunc newmsg, void *msghandle, int mask)</td><td>void putMsgfunc(MsgListener listener, Object userhandle, int mask) throws LpSolveException</td></tr>
<tr><td>lprec *read_freeMPS(char *filename, int options)</td><td>static LpSolve readFreeMps(String filename, int options) throws LpSolveException</td></tr>
<tr><td>lprec *read_freemps(FILE *stream, int options)</td><td><strong>&lt;Not implemented, use readFreeMps instead&gt;</strong></td></tr>
<tr><td>lprec *read_lp(FILE *stream, int verbose, char *lp_name)</td><td><strong>&lt;Not implemented, use readLp instead&gt;</strong></td></tr>
<tr><td>lprec *read_LP(char *filename, int verbose, char *lp_name)</td><td>static LpSolve readLp(String filename, int verbose, String lpName) throws LpSolveException</td></tr>
<tr><td>lprec *read_lpt(FILE *stream, int verbose, char *lp_name)</td><td><strong>&lt;Not implemented, use readLpt instead&gt;</strong></td></tr>
<tr><td>lprec *read_LPT(char *filename, int verbose, char *lp_name)</td><td>static LpSolve readLpt(String filename, int verbose, String lpName) throws LpSolveException</td></tr>
<tr><td>lprec *read_mps(FILE *stream, int options)</td><td><strong>&lt;Not implemented, use readMps instead&gt;</strong></td></tr>
<tr><td>lprec *read_MPS(char *filename, int options)</td><td>static LpSolve readMps(String filename, int options) throws LpSolveException</td></tr>
<tr><td>lprec *read_XLI(char *xliname, char *modelname, char *dataname, char *options, int verbose)</td><td>static LpSolve readXLI(String xliname, String modelname, String dataname, String options, int verbose)	throws LpSolveException</td></tr>
<tr><td>void reset_basis(lprec *lp)</td><td>void resetBasis()</td></tr>
<tr><td>unsigned char resize_lp(lprec *lp, int rows, int columns)</td><td>void resizeLp(int rows, int columns) throws LpSolveException</td></tr>
<tr><td>unsigned char set_add_rowmode(lprec *lp, unsigned char turnon)</td><td>boolean setAddRowmode(boolean turnon)</td></tr>
<tr><td>void set_anti_degen(lprec *lp, int anti_degen)</td><td>void setAntiDegen(int antiDegen)</td></tr>
<tr><td>unsigned char set_basis(lprec *lp, int *bascolumn, unsigned char nonbasic)</td><td>void setBasis(int[] bascolumn, boolean nonbasic) throws LpSolveException</td></tr>
<tr><td>void set_basiscrash(lprec *lp, int mode)</td><td>void setBasiscrash(int mode)</td></tr>
<tr><td>void set_bb_depthlimit(lprec *lp, int bb_maxlevel)</td><td>void setBbDepthlimit(int bbMaxlevel)</td></tr>
<tr><td>void set_bb_floorfirst(lprec *lp, int bb_floorfirst)</td><td>void setBbFloorfirst(int floorFirst)</td></tr>
<tr><td>void set_bb_rule(lprec *lp, int bb_rule)</td><td>void setBbRule(int bbRule)</td></tr>
<tr><td>unsigned char set_BFP(lprec *lp, char *filename)</td><td>void setBFP(String filename) throws LpSolveException</td></tr>
<tr><td>unsigned char set_XLI(lprec *lp, char *filename)</td><td>void setXLI(String filename) throws LpSolveException</td></tr>
<tr><td>unsigned char set_binary(lprec *lp, int column, unsigned char must_be_bin)</td><td>void setBinary(int colnr, boolean mustBeBin) throws LpSolveException</td></tr>
<tr><td>unsigned char set_bounds(lprec *lp, int column, REAL lower, REAL upper)</td><td>void setBounds(int colnr, double lower, double upper) throws LpSolveException</td></tr>
<tr><td>void set_bounds_tighter(lprec *lp, unsigned char tighten)</td><td>void setBoundsTighter(boolean tighten)</td></tr>
<tr><td>void set_break_at_first(lprec *lp, unsigned char break_at_first)</td><td>void setBreakAtFirst(boolean breakAtFirst)</td></tr>
<tr><td>void set_break_at_value(lprec *lp, REAL break_at_value)</td><td>void setBreakAtValue(double breakAtValue)</td></tr>
<tr><td>unsigned char set_col_name(lprec *lp, int column, char *new_name)</td><td>void setColName(int colnr, String name) throws LpSolveException</td></tr>
<tr><td>unsigned char set_column(lprec *lp, int col_no, REAL *column)</td><td>void setColumn(int colno, double[] column) throws LpSolveException</td></tr>
<tr><td>unsigned char set_columnex(lprec *lp, int col_no, int count, REAL *column, int *rowno)</td><td>void setColumnex(int colno, int count, double[] column, int[] rowno) throws LpSolveException</td></tr>
<tr><td>unsigned char set_constr_type(lprec *lp, int row, int con_type)</td><td>void setConstrType(int rownr, int constrType) throws LpSolveException</td></tr>
<tr><td>void set_debug(lprec *lp, unsigned char debug)</td><td>void setDebug(boolean debug)</td></tr>
<tr><td>void set_epsb(lprec *lp, REAL epsb)</td><td>void setEpsb(double value)</td></tr>
<tr><td>void set_epsd(lprec *lp, REAL epsd)</td><td>void setEpsd(double value)</td></tr>
<tr><td>void set_epsel(lprec *lp, REAL epsel)</td><td>void setEpsel(double value)</td></tr>
<tr><td>void set_epsint(lprec *lp, REAL epsint)</td><td>void setEpsint(double value)</td></tr>
<tr><td>void set_epsperturb(lprec *lp, REAL epsperturb)</td><td>void setEpsperturb(double value)</td></tr>
<tr><td>void set_epspivot(lprec *lp, REAL epspivot)</td><td>void setEpspivot(double value)</td></tr>
<tr><td>unsigned char set_free(lprec *lp, int column)</td><td>void setFree(int colnr) throws LpSolveException</td></tr>
<tr><td>void set_improve(lprec *lp, int improve)</td><td>void setImprove(int improve)</td></tr>
<tr><td>void set_infinite(lprec *lp, REAL infinite)</td><td>void setInfinite(double value)</td></tr>
<tr><td>unsigned char set_int(lprec *lp, int column, unsigned char must_be_int)</td><td>void setInt(int colnr, boolean mustBeInteger) throws LpSolveException</td></tr>
<tr><td>void set_lag_trace(lprec *lp, unsigned char lag_trace)</td><td>void setLagTrace(boolean lagTrace)</td></tr>
<tr><td>unsigned char set_lowbo(lprec *lp, int column, REAL value)</td><td>void setLowbo(int colnr, double value) throws LpSolveException</td></tr>
<tr><td>unsigned char set_lp_name(lprec *lp, char *lpname)</td><td>void setLpName(String name) throws LpSolveException</td></tr>
<tr><td>unsigned char set_mat(lprec *lp, int row, int column, REAL value)</td><td>void setMat(int row, int column, double value) throws LpSolveException</td></tr>
<tr><td>void set_maxim(lprec *lp)</td><td>void setMaxim()</td></tr>
<tr><td>void set_maxpivot(lprec *lp, int max_num_inv)</td><td>void setMaxpivot(int maxNumInv)</td></tr>
<tr><td>void set_minim(lprec *lp)</td><td>void setMinim()</td></tr>
<tr><td>void set_mip_gap(lprec *lp, unsigned char absolute, REAL mip_gap)</td><td>void setMipGap(boolean absolute, double value)</td></tr>
<tr><td>void set_negrange(lprec *lp, REAL negrange)</td><td>void setNegrange(double negRange)</td></tr>
<tr><td>void set_obj_bound(lprec *lp, REAL obj_bound)</td><td>void setObjBound(double objBound)</td></tr>
<tr><td>unsigned char set_obj_fn(lprec *lp, REAL *row)</td><td>void setObjFn(double[] row) throws LpSolveException</td></tr>
<tr><td>unsigned char set_obj_fnex(lprec *lp, int count, REAL *row, int *colno)</td><td>void setObjFnex(int count, double[] row, int[] colno) throws LpSolveException</td></tr>
<tr><td>unsigned char set_obj(lprec *lp, int column, REAL value)</td><td>void setObj(int column, double value) throws LpSolveException</td></tr>
<tr><td>void set_outputstream(lprec *lp, FILE *stream)</td><td><strong>&lt;Not implemented, use setOutputfile instead&gt;</strong></td></tr>
<tr><td>unsigned char set_outputfile(lprec *lp, char *filename)</td><td>void setOutputfile(String filename) throws LpSolveException</td></tr>
<tr><td>void set_pivoting(lprec *lp, int pivoting)</td><td>void setPivoting(int pivRule)</td></tr>
<tr><td>void set_preferdual(lprec *lp, unsigned char dodual)</td><td>void setPreferdual(int dodual)</td></tr>
<tr><td>void set_presolve(lprec *lp, int do_presolve)</td><td>void setPresolve(int doPresolve)</td></tr>
<tr><td>void set_print_sol(lprec *lp, int print_sol)</td><td>void setPrintSol(int printSol)</td></tr>
<tr><td>unsigned char set_rh(lprec *lp, int row, REAL value)</td><td>void setRh(int row, double value) throws LpSolveException</td></tr>
<tr><td>unsigned char set_rh_range(lprec *lp, int row, REAL deltavalue)</td><td>void setRhRange(int rownr, double range) throws LpSolveException</td></tr>
<tr><td>void set_rh_vec(lprec *lp, REAL *rh)</td><td>void setRhVec(double[] rh) throws LpSolveException</td></tr>
<tr><td>unsigned char set_row(lprec *lp, int row_no, REAL *row)</td><td>void setRow(int rowno, double[] row) throws LpSolveException</td></tr>
<tr><td>unsigned char set_rowex(lprec *lp, int row_no, int count, REAL *row, int *colno)</td><td>void setRowex(int rowno, int count, double[] row, int[] colno) throws LpSolveException</td></tr>
<tr><td>unsigned char set_row_name(lprec *lp, int row, char *new_name)</td><td>void setRowName(int rownr, String name) throws LpSolveException</td></tr>
<tr><td>void set_scalelimit(lprec *lp, REAL scalelimit)</td><td>void setScalelimit(double scalelimit)</td></tr>
<tr><td>void set_scaling(lprec *lp, int scalemode)</td><td>void setScaling(int scalemode)</td></tr>
<tr><td>unsigned char set_semicont(lprec *lp, int column, unsigned char must_be_sc)</td><td>void setSemicont(int colnr, boolean mustBeSc) throws LpSolveException</td></tr>
<tr><td>void set_sense(lprec *lp, unsigned char maximize)</td><td>void setSense(boolean maximize)</td></tr>
<tr><td>void set_simplextype(lprec *lp, int simplextype)</td><td>void setSimplextype(int simplextype)</td></tr>
<tr><td>void set_solutionlimit(lprec *lp, int limit)</td><td>void setSolutionlimit(int limit)</td></tr>
<tr><td>void set_timeout(lprec *lp, long sectimeout)</td><td>void setTimeout(long timeout)</td></tr>
<tr><td>void set_trace(lprec *lp, unsigned char trace)</td><td>void setTrace(boolean trace)</td></tr>
<tr><td>unsigned char set_upbo(lprec *lp, int column, REAL value)</td><td>void setUpbo(int colnr, double value) throws LpSolveException</td></tr>
<tr><td>unsigned char set_var_branch(lprec *lp, int column, int branch_mode)</td><td>void setVarBranch(int colnr, int branchMode) throws LpSolveException</td></tr>
<tr><td>unsigned char set_var_weights(lprec *lp, REAL *weights)</td><td>void setVarWeights(double[] weights) throws LpSolveException</td></tr>
<tr><td>void set_verbose(lprec *lp, int verbose)</td><td>void setVerbose(int verbose)</td></tr>
<tr><td>int solve(lprec *lp)</td><td>int solve() throws LpSolveException</td></tr>
<tr><td>unsigned char str_add_column (lprec* lp, char* col_string)</td><td>void strAddColumn(String column) throws LpSolveException</td></tr>
<tr><td>unsigned char str_add_constraint (lprec* lp, char *row_string, int constr_type, REAL rh)</td><td>void strAddConstraint(String row, int constrType, double rh) throws LpSolveException</td></tr>
<tr><td>unsigned char str_add_lag_con (lprec* lp, char *row_string, int con_type, REAL rhs)</td><td>void strAddLagCon(String row, int constrType, double rh) throws LpSolveException</td></tr>
<tr><td>unsigned char str_set_obj_fn(lprec *lp, char *row_string)</td><td>void strSetObjFn(String row) throws LpSolveException</td></tr>
<tr><td>unsigned char str_set_rh_vec(lprec *lp, char *rh_string)</td><td>void strSetRhVec(String rh) throws LpSolveException</td></tr>
<tr><td>REAL time_elapsed(lprec *lp)</td><td>double timeElapsed()</td></tr>
<tr><td>void unscale(lprec *lp)</td><td>void unscale()</td></tr>
<tr><td>unsigned char write_freeMPS(lprec *lp, FILE *stream)</td><td><strong>&lt;Not implemented, use writeFreeMps instead&gt;</strong></td></tr>
<tr><td>unsigned char write_freemps(lprec *lp, char *filename)</td><td>void writeFreeMps(String filename) throws LpSolveException</td></tr>
<tr><td>unsigned char write_lp(lprec *lp, char *filename)</td><td>void writeLp(String filename) throws LpSolveException</td></tr>
<tr><td>unsigned char write_LP(lprec *lp, FILE *stream)</td><td><strong>&lt;Not implemented, use writeLp instead&gt;</strong></td></tr>
<tr><td>unsigned char write_mps(lprec *lp, char *filename)</td><td>void writeMps(String filename) throws LpSolveException</td></tr>
<tr><td>unsigned char write_MPS(lprec *lp, FILE *stream)</td><td><strong>&lt;Not implemented, use writeMps instead&gt;</strong></td></tr>
<tr><td>unsigned char write_XLI(lprec *lp, char *filename, char *options, unsigned char results)</td><td>void writeXLI(String filename, String options, boolean results) throws LpSolveException</td></tr>
</table>

</body>
</html>
