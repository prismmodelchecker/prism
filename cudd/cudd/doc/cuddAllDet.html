<html>
<head><title>The cudd package (Internal) </title></head>
<body>

<h1>The cudd package (Internal) </h1>
<h2>Internal data structures of the CUDD package.</h2>
<h3></h3>
<hr>
<ul>
<li><a href="cuddExtAbs.html"><h3>External abstracts</h3></a>
<li><a href="cuddAllAbs.html"><h3>All abstracts</h3></a>
<li><a href="cuddExtDet.html#prototypes"><h3>External functions</h3></a>
<li><a href="cuddAllDet.html#prototypes"><h3>All functions</h3></a>
</ul>

<hr>

<a name="description">

</a>

<hr>
<!-- Function Prototypes and description -->

<dl>
<a name="prototypes"></a>
<dt><pre>
int <i></i>
<a name="Cudd_AddHook"><b>Cudd_AddHook</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DD_HFP  <b>f</b>, <i></i>
  Cudd_HookType  <b>where</b> <i></i>
)
</pre>
<dd> Adds a function to a hook. A hook is a list of application-provided functions called on certain occasions by the package. Returns 1 if the function is successfully added; 2 if the function was already in the list; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_RemoveHook">Cudd_RemoveHook</a>
</code>

<dt><pre>
DdApaDigit <i></i>
<a name="Cudd_ApaAdd"><b>Cudd_ApaAdd</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>a</b>, <i></i>
  DdApaNumber  <b>b</b>, <i></i>
  DdApaNumber  <b>sum</b> <i></i>
)
</pre>
<dd> Adds two arbitrary precision integers. Returns the carry out of the most significant digit.
<p>

<dd> <b>Side Effects</b> The result of the sum is stored in parameter <code>sum</code>.
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ApaCompareRatios"><b>Cudd_ApaCompareRatios</b></a>(
  int  <b>digitsFirst</b>, <i></i>
  DdApaNumber  <b>firstNum</b>, <i></i>
  unsigned int  <b>firstDen</b>, <i></i>
  int  <b>digitsSecond</b>, <i></i>
  DdApaNumber  <b>secondNum</b>, <i></i>
  unsigned int  <b>secondDen</b> <i></i>
)
</pre>
<dd> Compares the ratios of two arbitrary precision integers to two unsigned ints. Returns 1 if the first number is larger; 0 if they are equal; -1 if the second number is larger.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ApaCompare"><b>Cudd_ApaCompare</b></a>(
  int  <b>digitsFirst</b>, <i></i>
  DdApaNumber  <b>first</b>, <i></i>
  int  <b>digitsSecond</b>, <i></i>
  DdApaNumber  <b>second</b> <i></i>
)
</pre>
<dd> Compares two arbitrary precision integers. Returns 1 if the first number is larger; 0 if they are equal; -1 if the second number is larger.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="Cudd_ApaCopy"><b>Cudd_ApaCopy</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>source</b>, <i></i>
  DdApaNumber  <b>dest</b> <i></i>
)
</pre>
<dd> Makes a copy of an arbitrary precision integer.
<p>

<dd> <b>Side Effects</b> Changes parameter <code>dest</code>.
<p>

<dt><pre>
DdApaNumber <i></i>
<a name="Cudd_ApaCountMinterm"><b>Cudd_ApaCountMinterm</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  int * <b>digits</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a DD. The function is assumed to depend on nvars variables. The minterm count is represented as an arbitrary precision unsigned integer, to allow for any number of variables CUDD supports. Returns a pointer to the array representing the number of minterms of the function rooted at node if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The number of digits of the result is returned in parameter <code>digits</code>.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_CountMinterm">Cudd_CountMinterm</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ApaIntDivision"><b>Cudd_ApaIntDivision</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>dividend</b>, <i></i>
  unsigned int  <b>divisor</b>, <i></i>
  DdApaNumber  <b>quotient</b> <i></i>
)
</pre>
<dd> Divides an arbitrary precision integer by a 32-bit unsigned integer. Returns the remainder of the division. This procedure relies on the assumption that the number of bits of a DdApaDigit plus the number of bits of an unsigned int is less the number of bits of the mantissa of a double. This guarantees that the product of a DdApaDigit and an unsigned int can be represented without loss of precision by a double. On machines where this assumption is not satisfied, this procedure will malfunction.
<p>

<dd> <b>Side Effects</b> The quotient is returned in parameter <code>quotient</code>.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ApaShortDivision">Cudd_ApaShortDivision</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ApaNumberOfDigits"><b>Cudd_ApaNumberOfDigits</b></a>(
  int  <b>binaryDigits</b> <i></i>
)
</pre>
<dd> Finds the number of digits for an arbitrary precision integer given the maximum number of binary digits. The number of binary digits should be positive. Returns the number of digits if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="Cudd_ApaPowerOfTwo"><b>Cudd_ApaPowerOfTwo</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b>, <i></i>
  int  <b>power</b> <i></i>
)
</pre>
<dd> Sets an arbitrary precision integer to a power of two. If the power of two is too large to be represented, the number is set to 0.
<p>

<dd> <b>Side Effects</b> The result is returned in parameter <code>number</code>.
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ApaPrintDecimal"><b>Cudd_ApaPrintDecimal</b></a>(
  FILE * <b>fp</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b> <i></i>
)
</pre>
<dd> Prints an arbitrary precision integer in decimal format. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ApaPrintHex">Cudd_ApaPrintHex</a>
<a href="cuddAllDet.html#Cudd_ApaPrintExponential">Cudd_ApaPrintExponential</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ApaPrintDensity"><b>Cudd_ApaPrintDensity</b></a>(
  FILE * <b>fp</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b> <i></i>
)
</pre>
<dd> Prints the density of a BDD or ADD using arbitrary precision arithmetic. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ApaPrintExponential"><b>Cudd_ApaPrintExponential</b></a>(
  FILE * <b>fp</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b>, <i></i>
  int  <b>precision</b> <i></i>
)
</pre>
<dd> Prints an arbitrary precision integer in exponential format. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ApaPrintHex">Cudd_ApaPrintHex</a>
<a href="cuddAllDet.html#Cudd_ApaPrintDecimal">Cudd_ApaPrintDecimal</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ApaPrintHex"><b>Cudd_ApaPrintHex</b></a>(
  FILE * <b>fp</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b> <i></i>
)
</pre>
<dd> Prints an arbitrary precision integer in hexadecimal format. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ApaPrintDecimal">Cudd_ApaPrintDecimal</a>
<a href="cuddAllDet.html#Cudd_ApaPrintExponential">Cudd_ApaPrintExponential</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ApaPrintMintermExp"><b>Cudd_ApaPrintMintermExp</b></a>(
  FILE * <b>fp</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  int  <b>precision</b> <i></i>
)
</pre>
<dd> Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithmetic. Parameter precision controls the number of signficant digits printed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ApaPrintMinterm">Cudd_ApaPrintMinterm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ApaPrintMinterm"><b>Cudd_ApaPrintMinterm</b></a>(
  FILE * <b>fp</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b> <i></i>
)
</pre>
<dd> Prints the number of minterms of a BDD or ADD using arbitrary precision arithmetic. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ApaPrintMintermExp">Cudd_ApaPrintMintermExp</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_ApaSetToLiteral"><b>Cudd_ApaSetToLiteral</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b>, <i></i>
  DdApaDigit  <b>literal</b> <i></i>
)
</pre>
<dd> Sets an arbitrary precision integer to a one-digit literal.
<p>

<dd> <b>Side Effects</b> The result is returned in parameter <code>number</code>.
<p>

<dt><pre>
void <i></i>
<a name="Cudd_ApaShiftRight"><b>Cudd_ApaShiftRight</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaDigit  <b>in</b>, <i></i>
  DdApaNumber  <b>a</b>, <i></i>
  DdApaNumber  <b>b</b> <i></i>
)
</pre>
<dd> Shifts right an arbitrary precision integer by one binary place. The most significant binary digit of the result is taken from parameter <code>in</code>.
<p>

<dd> <b>Side Effects</b> The result is returned in parameter <code>b</code>.
<p>

<dt><pre>
DdApaDigit <i></i>
<a name="Cudd_ApaShortDivision"><b>Cudd_ApaShortDivision</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>dividend</b>, <i></i>
  DdApaDigit  <b>divisor</b>, <i></i>
  DdApaNumber  <b>quotient</b> <i></i>
)
</pre>
<dd> Divides an arbitrary precision integer by a digit.
<p>

<dd> <b>Side Effects</b> The quotient is returned in parameter <code>quotient</code>.
<p>

<dt><pre>
DdApaDigit <i></i>
<a name="Cudd_ApaSubtract"><b>Cudd_ApaSubtract</b></a>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>a</b>, <i></i>
  DdApaNumber  <b>b</b>, <i></i>
  DdApaNumber  <b>diff</b> <i></i>
)
</pre>
<dd> Subtracts two arbitrary precision integers. Returns the borrow out of the most significant digit.
<p>

<dd> <b>Side Effects</b> The result of the subtraction is stored in parameter <code>diff</code>.
<p>

<dt><pre>
void <i></i>
<a name="Cudd_AutodynDisableZdd"><b>Cudd_AutodynDisableZdd</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables automatic dynamic reordering of ZDDs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AutodynEnableZdd">Cudd_AutodynEnableZdd</a>
<a href="cuddAllDet.html#Cudd_ReorderingStatusZdd">Cudd_ReorderingStatusZdd</a>
<a href="cuddAllDet.html#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_AutodynDisable"><b>Cudd_AutodynDisable</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables automatic dynamic reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AutodynEnable">Cudd_AutodynEnable</a>
<a href="cuddAllDet.html#Cudd_ReorderingStatus">Cudd_ReorderingStatus</a>
<a href="cuddAllDet.html#Cudd_AutodynDisableZdd">Cudd_AutodynDisableZdd</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_AutodynEnableZdd"><b>Cudd_AutodynEnableZdd</b></a>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Enables automatic dynamic reordering of ZDDs. Parameter method is used to determine the method used for reordering ZDDs. If CUDD_REORDER_SAME is passed, the method is unchanged.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AutodynDisableZdd">Cudd_AutodynDisableZdd</a>
<a href="cuddAllDet.html#Cudd_ReorderingStatusZdd">Cudd_ReorderingStatusZdd</a>
<a href="cuddAllDet.html#Cudd_AutodynEnable">Cudd_AutodynEnable</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_AutodynEnable"><b>Cudd_AutodynEnable</b></a>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Enables automatic dynamic reordering of BDDs and ADDs. Parameter method is used to determine the method used for reordering. If CUDD_REORDER_SAME is passed, the method is unchanged.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
<a href="cuddAllDet.html#Cudd_ReorderingStatus">Cudd_ReorderingStatus</a>
<a href="cuddAllDet.html#Cudd_AutodynEnableZdd">Cudd_AutodynEnableZdd</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_AverageDistance"><b>Cudd_AverageDistance</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Computes the average distance between adjacent nodes in the manager. Adjacent nodes are node pairs such that the second node is the then child, else child, or next node in the collision list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_BddToAdd"><b>Cudd_BddToAdd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b> <i></i>
)
</pre>
<dd> Converts a BDD to a 0-1 ADD. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="cuddAllDet.html#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
<a href="cuddAllDet.html#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="cuddAllDet.html#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_BddToCubeArray"><b>Cudd_BddToCubeArray</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  int * <b>array</b> <i></i>
)
</pre>
<dd> Builds a positional array from the BDD of a cube. Array must have one entry for each BDD variable. The positional array has 1 in i-th position if the variable of index i appears in true form in the cube; it has 0 in i-th position if the variable of index i appears in complemented form in the cube; finally, it has 2 in i-th position if the variable of index i does not appear in the cube. Returns 1 if successful (the BDD is indeed a cube); 0 otherwise.
<p>

<dd> <b>Side Effects</b> The result is in the array passed by reference.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_CubeArrayToBdd">Cudd_CubeArrayToBdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_BiasedOverApprox"><b>Cudd_BiasedOverApprox</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  DdNode * <b>b</b>, <i>bias function</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. Returns a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="cuddAllDet.html#Cudd_RemapOverApprox">Cudd_RemapOverApprox</a>
<a href="cuddAllDet.html#Cudd_BiasedUnderApprox">Cudd_BiasedUnderApprox</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_BiasedUnderApprox"><b>Cudd_BiasedUnderApprox</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  DdNode * <b>b</b>, <i>bias function</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure uses a biased remapping technique and density as the cost function. The bias is a function. This procedure tries to approximate where the bias is 0 and preserve the given function where the bias is 1. Returns a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_UnderApprox">Cudd_UnderApprox</a>
<a href="cuddAllDet.html#Cudd_RemapUnderApprox">Cudd_RemapUnderApprox</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_CProjection"><b>Cudd_CProjection</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>R</b>, <i></i>
  DdNode * <b>Y</b> <i></i>
)
</pre>
<dd> Computes the compatible projection of relation R with respect to cube Y. Returns a pointer to the c-projection if successful; NULL otherwise. For a comparison between Cudd_CProjection and Cudd_PrioritySelect, see the documentation of the latter.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_CheckKeys"><b>Cudd_CheckKeys</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Checks for the following conditions: <ul> <li>Wrong sizes of subtables. <li>Wrong number of keys found in unique subtable. <li>Wrong number of dead found in unique subtable. <li>Wrong number of keys found in the constant table <li>Wrong number of dead found in the constant table <li>Wrong number of total slots found <li>Wrong number of maximum keys found <li>Wrong number of total dead found </ul> Reports the average length of non-empty lists. Returns the number of subtables for which the number of keys is wrong.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DebugCheck">Cudd_DebugCheck</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_CheckZeroRef"><b>Cudd_CheckZeroRef</b></a>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Checks the unique table for nodes with non-zero reference counts. It is normally called before Cudd_Quit to make sure that there are no memory leaks due to missing Cudd_RecursiveDeref's. Takes into account that reference counts may saturate and that the basic constants and the projection functions are referenced by the manager. Returns the number of nodes with non-zero reference count. (Except for the cases mentioned above.)
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ClassifySupport"><b>Cudd_ClassifySupport</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first DD</i>
  DdNode * <b>g</b>, <i>second DD</i>
  DdNode ** <b>common</b>, <i>cube of shared variables</i>
  DdNode ** <b>onlyF</b>, <i>cube of variables only in f</i>
  DdNode ** <b>onlyG</b> <i>cube of variables only in g</i>
)
</pre>
<dd> Classifies the variables in the support of two DDs <code>f</code> and <code>g</code>, depending on whther they appear in both DDs, only in <code>f</code>, or only in <code>g</code>. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The cubes of the three classes of variables are returned as side effects.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Support">Cudd_Support</a>
<a href="cuddAllDet.html#Cudd_VectorSupport">Cudd_VectorSupport</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_ClearErrorCode"><b>Cudd_ClearErrorCode</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Clear the error code of a manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadErrorCode">Cudd_ReadErrorCode</a>
</code>

<dt><pre>
double * <i></i>
<a name="Cudd_CofMinterm"><b>Cudd_CofMinterm</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Computes the fraction of minterms in the on-set of all the positive cofactors of DD. Returns the pointer to an array of doubles if successful; NULL otherwise. The array hs as many positions as there are BDD variables in the manager plus one. The last position of the array contains the fraction of the minterms in the ON-set of the function represented by the BDD or ADD. The other positions of the array hold the variable signatures.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Cofactor"><b>Cudd_Cofactor</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the cofactor of f with respect to g; g must be the BDD or the ADD of a cube. Returns a pointer to the cofactor if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_Complement"><b>Cudd_Complement</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the complemented version of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Regular">Cudd_Regular</a>
<a href="cuddAllDet.html#Cudd_IsComplement">Cudd_IsComplement</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_CountLeaves"><b>Cudd_CountLeaves</b></a>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of leaves in a DD. Returns the number of leaves in the DD rooted at node if successful; CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_CountMinterm"><b>Cudd_CountMinterm</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a DD. The function is assumed to depend on nvars variables. The minterm count is represented as a double, to allow for a larger number of variables. Returns the number of minterms of the function rooted at node if successful; (double) CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_CountPath">Cudd_CountPath</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_CountPathsToNonZero"><b>Cudd_CountPathsToNonZero</b></a>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of paths to a non-zero terminal of a DD. The path count is represented as a double, to allow for a larger number of variables. Returns the number of paths of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_CountMinterm">Cudd_CountMinterm</a>
<a href="cuddAllDet.html#Cudd_CountPath">Cudd_CountPath</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_CountPath"><b>Cudd_CountPath</b></a>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of paths of a DD. Paths to all terminal nodes are counted. The path count is represented as a double, to allow for a larger number of variables. Returns the number of paths of the function rooted at node if successful; (double) CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_CountMinterm">Cudd_CountMinterm</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_CubeArrayToBdd"><b>Cudd_CubeArrayToBdd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int * <b>array</b> <i></i>
)
</pre>
<dd> Builds a cube from a positional array. The array must have one integer entry for each BDD variable. If the i-th entry is 1, the variable of index i appears in true form in the cube; If the i-th entry is 0, the variable of index i appears complemented in the cube; otherwise the variable does not appear in the cube. Returns a pointer to the BDD for the cube if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddComputeCube">Cudd_bddComputeCube</a>
<a href="cuddAllDet.html#Cudd_IndicesToCube">Cudd_IndicesToCube</a>
<a href="cuddAllDet.html#Cudd_BddToCubeArray">Cudd_BddToCubeArray</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DagSize"><b>Cudd_DagSize</b></a>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of nodes in a DD. Returns the number of nodes in the graph rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SharingSize">Cudd_SharingSize</a>
<a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DeadAreCounted"><b>Cudd_DeadAreCounted</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Tells whether dead nodes are counted towards triggering reordering. Returns 1 if dead nodes are counted; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_TurnOnCountDead">Cudd_TurnOnCountDead</a>
<a href="cuddAllDet.html#Cudd_TurnOffCountDead">Cudd_TurnOffCountDead</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DebugCheck"><b>Cudd_DebugCheck</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Checks for inconsistencies in the DD heap: <ul> <li> node has illegal index <li> live node has dead children <li> node has illegal Then or Else pointers <li> BDD/ADD node has identical children <li> ZDD node has zero then child <li> wrong number of total nodes <li> wrong number of dead nodes <li> ref count error at node </ul> Returns 0 if no inconsistencies are found; DD_OUT_OF_MEM if there is not enough memory; 1 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_CheckKeys">Cudd_CheckKeys</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Decreasing"><b>Cudd_Decreasing</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Determines whether the function represented by BDD f is negative unate (monotonic decreasing) in variable i. Returns the constant one is f is unate and the (logical) constant zero if it is not. This function does not generate any new nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Increasing">Cudd_Increasing</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_DelayedDerefBdd"><b>Cudd_DelayedDerefBdd</b></a>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Enqueues node n for later dereferencing. If the queue is full decreases the reference count of the oldest node N to make room for n. If N dies, recursively decreases the reference counts of its children. It is used to dispose of a BDD that is currently not needed, but may be useful again in the near future. The dereferencing proper is done as in Cudd_IterDerefBdd.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="cuddAllDet.html#Cudd_IterDerefBdd">Cudd_IterDerefBdd</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_Density"><b>Cudd_Density</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function whose density is sought</i>
  int  <b>nvars</b> <i>size of the support of f</i>
)
</pre>
<dd> Computes the density of a BDD or ADD. The density is the ratio of the number of minterms to the number of nodes. If 0 is passed as number of variables, the number of variables existing in the manager is used. Returns the density if successful; (double) CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_CountMinterm">Cudd_CountMinterm</a>
<a href="cuddAllDet.html#Cudd_DagSize">Cudd_DagSize</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_Deref"><b>Cudd_Deref</b></a>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Decreases the reference count of node. It is primarily used in recursive procedures to decrease the ref count of a result node before returning it. This accomplishes the goal of removing the protection applied by a previous Cudd_Ref.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="cuddAllDet.html#Cudd_RecursiveDerefZdd">Cudd_RecursiveDerefZdd</a>
<a href="cuddAllDet.html#Cudd_Ref">Cudd_Ref</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_DisableGarbageCollection"><b>Cudd_DisableGarbageCollection</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Disables garbage collection. Garbage collection is initially enabled. This function may be called to disable it. However, garbage collection will still occur when a new node must be created and no memory is left, or when garbage collection is required for correctness. (E.g., before reordering.)
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_EnableGarbageCollection">Cudd_EnableGarbageCollection</a>
<a href="cuddAllDet.html#Cudd_GarbageCollectionEnabled">Cudd_GarbageCollectionEnabled</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DisableReorderingReporting"><b>Cudd_DisableReorderingReporting</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Disables reporting of reordering stats. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Removes functions from the pre-reordering and post-reordering hooks.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_EnableReorderingReporting">Cudd_EnableReorderingReporting</a>
<a href="cuddAllDet.html#Cudd_ReorderingReporting">Cudd_ReorderingReporting</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DumpBlifBody"><b>Cudd_DumpBlifBody</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a blif body representing the argument BDDs as a network of multiplexers. No header (.model, .inputs, and .outputs) and footer (.end) are produced by this function. One multiplexer is written for each BDD node. It returns 1 in case of success; 0 otherwise (e.g., out-of-memory, file system full, or an ADD with constants different from 0 and 1). Cudd_DumpBlifBody does not close the file: This is the caller responsibility. Cudd_DumpBlifBody uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames. This function prints out only .names part.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="cuddAllDet.html#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="cuddAllDet.html#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="cuddAllDet.html#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DumpBlif"><b>Cudd_DumpBlif</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  char * <b>mname</b>, <i>model name (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a blif file representing the argument BDDs as a network of multiplexers. One multiplexer is written for each BDD node. It returns 1 in case of success; 0 otherwise (e.g., out-of-memory, file system full, or an ADD with constants different from 0 and 1). Cudd_DumpBlif does not close the file: This is the caller responsibility. Cudd_DumpBlif uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DumpBlifBody">Cudd_DumpBlifBody</a>
<a href="cuddAllDet.html#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="cuddAllDet.html#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="cuddAllDet.html#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DumpDDcal"><b>Cudd_DumpDDcal</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a DDcal file representing the argument BDDs. It returns 1 in case of success; 0 otherwise (e.g., out-of-memory or file system full). Cudd_DumpDDcal does not close the file: This is the caller responsibility. Cudd_DumpDDcal uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="cuddAllDet.html#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="cuddAllDet.html#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DumpDaVinci"><b>Cudd_DumpDaVinci</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a daVinci file representing the argument BDDs. It returns 1 in case of success; 0 otherwise (e.g., out-of-memory or file system full). Cudd_DumpDaVinci does not close the file: This is the caller responsibility. Cudd_DumpDaVinci uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="cuddAllDet.html#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="cuddAllDet.html#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DumpDot"><b>Cudd_DumpDot</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a file representing the argument DDs in a format suitable for the graph drawing program dot. It returns 1 in case of success; 0 otherwise (e.g., out-of-memory, file system full). Cudd_DumpDot does not close the file: This is the caller responsibility. Cudd_DumpDot uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames. Cudd_DumpDot uses the following convention to draw arcs: <ul> <li> solid line: THEN arcs; <li> dotted line: complement arcs; <li> dashed line: regular ELSE arcs. </ul> The dot options are chosen so that the drawing fits on a letter-size sheet.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="cuddAllDet.html#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="cuddAllDet.html#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_DumpFactoredForm"><b>Cudd_DumpFactoredForm</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes factored forms representing the argument BDDs. The format of the factored form is the one used in the genlib files for technology mapping in sis. It returns 1 in case of success; 0 otherwise (e.g., file system full). Cudd_DumpFactoredForm does not close the file: This is the caller responsibility. Caution must be exercised because a factored form may be exponentially larger than the argument BDD. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="cuddAllDet.html#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="cuddAllDet.html#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Dxygtdxz"><b>Cudd_Dxygtdxz</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x, y, and z variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b>, <i>array of y variables</i>
  DdNode ** <b>z</b> <i>array of z variables</i>
)
</pre>
<dd> This function generates a BDD for the function d(x,y) &gt; d(x,z); x, y, and z are N-bit numbers, x[0] x[1] ... x[N-1], y[0] y[1] ... y[N-1], and z[0] z[1] ... z[N-1], with 0 the most significant bit. The distance d(x,y) is defined as: sum_{i=0}^{N-1}(|x_i - y_i| cdot 2^{N-i-1}). The BDD is built bottom-up. It has 7*N-3 internal nodes, if the variables are ordered as follows: x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
<a href="cuddAllDet.html#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
<a href="cuddAllDet.html#Cudd_Xgty">Cudd_Xgty</a>
<a href="cuddAllDet.html#Cudd_bddAdjPermuteX">Cudd_bddAdjPermuteX</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Dxygtdyz"><b>Cudd_Dxygtdyz</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x, y, and z variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b>, <i>array of y variables</i>
  DdNode ** <b>z</b> <i>array of z variables</i>
)
</pre>
<dd> This function generates a BDD for the function d(x,y) &gt; d(y,z); x, y, and z are N-bit numbers, x[0] x[1] ... x[N-1], y[0] y[1] ... y[N-1], and z[0] z[1] ... z[N-1], with 0 the most significant bit. The distance d(x,y) is defined as: sum_{i=0}^{N-1}(|x_i - y_i| cdot 2^{N-i-1}). The BDD is built bottom-up. It has 7*N-3 internal nodes, if the variables are ordered as follows: x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
<a href="cuddAllDet.html#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="cuddAllDet.html#Cudd_Xgty">Cudd_Xgty</a>
<a href="cuddAllDet.html#Cudd_bddAdjPermuteX">Cudd_bddAdjPermuteX</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_EnableGarbageCollection"><b>Cudd_EnableGarbageCollection</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Enables garbage collection. Garbage collection is initially enabled. Therefore it is necessary to call this function only if garbage collection has been explicitly disabled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DisableGarbageCollection">Cudd_DisableGarbageCollection</a>
<a href="cuddAllDet.html#Cudd_GarbageCollectionEnabled">Cudd_GarbageCollectionEnabled</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_EnableReorderingReporting"><b>Cudd_EnableReorderingReporting</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Enables reporting of reordering stats. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Installs functions in the pre-reordering and post-reordering hooks.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DisableReorderingReporting">Cudd_DisableReorderingReporting</a>
<a href="cuddAllDet.html#Cudd_ReorderingReporting">Cudd_ReorderingReporting</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_EpdCountMinterm"><b>Cudd_EpdCountMinterm</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  EpDouble * <b>epd</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a DD with extended precision. The function is assumed to depend on nvars variables. The minterm count is represented as an EpDouble, to allow any number of variables. Returns 0 if successful; CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_CountPath">Cudd_CountPath</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_EqualSupNorm"><b>Cudd_EqualSupNorm</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first ADD</i>
  DdNode * <b>g</b>, <i>second ADD</i>
  CUDD_VALUE_TYPE  <b>tolerance</b>, <i>maximum allowed difference</i>
  int  <b>pr</b> <i>verbosity level</i>
)
</pre>
<dd> Compares two ADDs for equality within tolerance. Two ADDs are reported to be equal if the maximum difference between them (the sup norm of their difference) is less than or equal to the tolerance parameter. Returns 1 if the two ADDs are equal (within tolerance); 0 otherwise. If parameter <code>pr</code> is positive the first failure is reported to the standard output.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_EquivDC"><b>Cudd_EquivDC</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>F</b>, <i></i>
  DdNode * <b>G</b>, <i></i>
  DdNode * <b>D</b> <i></i>
)
</pre>
<dd> Tells whether F and G are identical wherever D is 0. F and G are either two ADDs or two BDDs. D is either a 0-1 ADD or a BDD. The function returns 1 if F and G are equivalent, and 0 otherwise. No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddLeqUnless">Cudd_bddLeqUnless</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_EstimateCofactorSimple"><b>Cudd_EstimateCofactorSimple</b></a>(
  DdNode * <b>node</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Estimates the number of nodes in a cofactor of a DD. Returns an estimate of the number of nodes in the positive cofactor of the graph rooted at node with respect to the variable whose index is i. This procedure implements with minor changes the algorithm of Cabodi et al. (ICCAD96). It does not allocate any memory, it does not change the state of the manager, and it is fast. However, it has been observed to overestimate the size of the cofactor by as much as a factor of 2.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DagSize">Cudd_DagSize</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_EstimateCofactor"><b>Cudd_EstimateCofactor</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function</i>
  int  <b>i</b>, <i>index of variable</i>
  int  <b>phase</b> <i>1: positive; 0: negative</i>
)
</pre>
<dd> Estimates the number of nodes in a cofactor of a DD. Returns an estimate of the number of nodes in a cofactor of the graph rooted at node with respect to the variable whose index is i. In case of failure, returns CUDD_OUT_OF_MEM. This function uses a refinement of the algorithm of Cabodi et al. (ICCAD96). The refinement allows the procedure to account for part of the recombination that may occur in the part of the cofactor above the cofactoring variable. This procedure does no create any new node. It does keep a small table of results; therefore itmay run out of memory. If this is a concern, one should use Cudd_EstimateCofactorSimple, which is faster, does not allocate any memory, but is less accurate.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DagSize">Cudd_DagSize</a>
<a href="cuddAllDet.html#Cudd_EstimateCofactorSimple">Cudd_EstimateCofactorSimple</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Eval"><b>Cudd_Eval</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>inputs</b> <i></i>
)
</pre>
<dd> Finds the value of a DD for a given variable assignment. The variable assignment is passed in an array of int's, that should specify a zero or a one for each variable in the support of the function. Returns a pointer to a constant node. No new nodes are produced.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="cuddAllDet.html#Cudd_addEvalConst">Cudd_addEvalConst</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ExpectedUsedSlots"><b>Cudd_ExpectedUsedSlots</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Computes the fraction of slots in the unique table that should be in use. This expected value is based on the assumption that the hash function distributes the keys randomly; it can be compared with the result of Cudd_ReadUsedSlots to monitor the performance of the unique table hash function.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadSlots">Cudd_ReadSlots</a>
<a href="cuddAllDet.html#Cudd_ReadUsedSlots">Cudd_ReadUsedSlots</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_E"><b>Cudd_E</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the else child of an internal node. If <code>node</code> is a constant node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_T">Cudd_T</a>
<a href="cuddAllDet.html#Cudd_V">Cudd_V</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_FindEssential"><b>Cudd_FindEssential</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the cube of the essential variables. A positive literal means that the variable must be set to 1 for the function to be 1. A negative literal means that the variable must be set to 0 for the function to be 1. Returns a pointer to the cube BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIsVarEssential">Cudd_bddIsVarEssential</a>
</code>

<dt><pre>
DdTlcInfo * <i></i>
<a name="Cudd_FindTwoLiteralClauses"><b>Cudd_FindTwoLiteralClauses</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the one- and two-literal clauses of a DD. Returns a pointer to the structure holding the clauses if successful; NULL otherwise. For a constant DD, the empty set of clauses is returned. This is obviously correct for a non-zero constant. For the constant zero, it is based on the assumption that only those clauses containing variables in the support of the function are considered. Since the support of a constant function is empty, no clauses are returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_FindEssential">Cudd_FindEssential</a>
</code>

<dt><pre>
DdGen * <i></i>
<a name="Cudd_FirstCube"><b>Cudd_FirstCube</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int ** <b>cube</b>, <i></i>
  CUDD_VALUE_TYPE * <b>value</b> <i></i>
)
</pre>
<dd> Defines an iterator on the onset of a decision diagram and finds its first cube. Returns a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.<p> A cube is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents a complemented literal, 1 represents an uncomplemented literal, and 2 stands for don't care. The enumeration produces a disjoint cover of the function associated with the diagram. The size of the array equals the number of variables in the manager at the time Cudd_FirstCube is called.<p> For each cube, a value is also returned. This value is always 1 for a BDD, while it may be different from 1 for an ADD. For BDDs, the offset is the set of cubes whose value is the logical zero. For ADDs, the offset is the set of cubes whose value is the background value. The cubes of the offset are not enumerated.
<p>

<dd> <b>Side Effects</b> The first cube and its value are returned as side effects.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="cuddAllDet.html#Cudd_NextCube">Cudd_NextCube</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_FirstNode">Cudd_FirstNode</a>
</code>

<dt><pre>
DdGen * <i></i>
<a name="Cudd_FirstNode"><b>Cudd_FirstNode</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>node</b> <i></i>
)
</pre>
<dd> Defines an iterator on the nodes of a decision diagram and finds its first node. Returns a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise. The nodes are enumerated in a reverse topological order, so that a node is always preceded in the enumeration by its descendants.
<p>

<dd> <b>Side Effects</b> The first node is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="cuddAllDet.html#Cudd_NextNode">Cudd_NextNode</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_FirstCube">Cudd_FirstCube</a>
</code>

<dt><pre>
DdGen * <i></i>
<a name="Cudd_FirstPrime"><b>Cudd_FirstPrime</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b>, <i></i>
  int ** <b>cube</b> <i></i>
)
</pre>
<dd> Defines an iterator on a pair of BDDs describing a (possibly incompletely specified) Boolean functions and finds the first cube of a cover of the function. Returns a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.<p> The two argument BDDs are the lower and upper bounds of an interval. It is a mistake to call this function with a lower bound that is not less than or equal to the upper bound.<p> A cube is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents a complemented literal, 1 represents an uncomplemented literal, and 2 stands for don't care. The enumeration produces a prime and irredundant cover of the function associated with the two BDDs. The size of the array equals the number of variables in the manager at the time Cudd_FirstCube is called.<p> This iterator can only be used on BDDs.
<p>

<dd> <b>Side Effects</b> The first cube is returned as side effect.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachPrime">Cudd_ForeachPrime</a>
<a href="cuddAllDet.html#Cudd_NextPrime">Cudd_NextPrime</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="cuddAllDet.html#Cudd_FirstNode">Cudd_FirstNode</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_ForeachCube"><b>Cudd_ForeachCube</b></a>(
   <b>manager</b>, <i></i>
   <b>f</b>, <i></i>
   <b>gen</b>, <i></i>
   <b>cube</b>, <i></i>
   <b>value</b> <i></i>
)
</pre>
<dd> Iterates over the cubes of a decision diagram f. <ul> <li> DdManager *manager; <li> DdNode *f; <li> DdGen *gen; <li> int *cube; <li> CUDD_VALUE_TYPE value; </ul> Cudd_ForeachCube allocates and frees the generator. Therefore the application should not try to do that. Also, the cube is freed at the end of Cudd_ForeachCube and hence is not available outside of the loop.<p> CAUTION: It is assumed that dynamic reordering will not occur while there are open generators. It is the user's responsibility to make sure that dynamic reordering does not occur. As long as new nodes are not created during generation, and dynamic reordering is not called explicitly, dynamic reordering will not occur. Alternatively, it is sufficient to disable dynamic reordering. It is a mistake to dispose of a diagram on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="cuddAllDet.html#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="cuddAllDet.html#Cudd_NextCube">Cudd_NextCube</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_ForeachNode"><b>Cudd_ForeachNode</b></a>(
   <b>manager</b>, <i></i>
   <b>f</b>, <i></i>
   <b>gen</b>, <i></i>
   <b>node</b> <i></i>
)
</pre>
<dd> Iterates over the nodes of a decision diagram f. <ul> <li> DdManager *manager; <li> DdNode *f; <li> DdGen *gen; <li> DdNode *node; </ul> The nodes are returned in a seemingly random order. Cudd_ForeachNode allocates and frees the generator. Therefore the application should not try to do that.<p> CAUTION: It is assumed that dynamic reordering will not occur while there are open generators. It is the user's responsibility to make sure that dynamic reordering does not occur. As long as new nodes are not created during generation, and dynamic reordering is not called explicitly, dynamic reordering will not occur. Alternatively, it is sufficient to disable dynamic reordering. It is a mistake to dispose of a diagram on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="cuddAllDet.html#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="cuddAllDet.html#Cudd_NextNode">Cudd_NextNode</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_ForeachPrime"><b>Cudd_ForeachPrime</b></a>(
   <b>manager</b>, <i></i>
   <b>l</b>, <i></i>
   <b>u</b>, <i></i>
   <b>gen</b>, <i></i>
   <b>cube</b> <i></i>
)
</pre>
<dd> Iterates over the primes of a Boolean function producing a prime and irredundant cover. <ul> <li> DdManager *manager; <li> DdNode *l; <li> DdNode *u; <li> DdGen *gen; <li> int *cube; </ul> The Boolean function is described by an upper bound and a lower bound. If the function is completely specified, the two bounds coincide. Cudd_ForeachPrime allocates and frees the generator. Therefore the application should not try to do that. Also, the cube is freed at the end of Cudd_ForeachPrime and hence is not available outside of the loop.<p> CAUTION: It is a mistake to change a diagram on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="cuddAllDet.html#Cudd_FirstPrime">Cudd_FirstPrime</a>
<a href="cuddAllDet.html#Cudd_NextPrime">Cudd_NextPrime</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_FreeTree"><b>Cudd_FreeTree</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Frees the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetTree">Cudd_SetTree</a>
<a href="cuddAllDet.html#Cudd_ReadTree">Cudd_ReadTree</a>
<a href="cuddAllDet.html#Cudd_FreeZddTree">Cudd_FreeZddTree</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_FreeZddTree"><b>Cudd_FreeZddTree</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Frees the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetZddTree">Cudd_SetZddTree</a>
<a href="cuddAllDet.html#Cudd_ReadZddTree">Cudd_ReadZddTree</a>
<a href="cuddAllDet.html#Cudd_FreeTree">Cudd_FreeTree</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_GarbageCollectionEnabled"><b>Cudd_GarbageCollectionEnabled</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns 1 if garbage collection is enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_EnableGarbageCollection">Cudd_EnableGarbageCollection</a>
<a href="cuddAllDet.html#Cudd_DisableGarbageCollection">Cudd_DisableGarbageCollection</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_GenFree"><b>Cudd_GenFree</b></a>(
  DdGen * <b>gen</b> <i></i>
)
</pre>
<dd> Frees a CUDD generator. Always returns 0, so that it can be used in mis-like foreach constructs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="cuddAllDet.html#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="cuddAllDet.html#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="cuddAllDet.html#Cudd_NextCube">Cudd_NextCube</a>
<a href="cuddAllDet.html#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="cuddAllDet.html#Cudd_NextNode">Cudd_NextNode</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Increasing"><b>Cudd_Increasing</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Determines whether the function represented by BDD f is positive unate (monotonic increasing) in variable i. It is based on Cudd_Decreasing and the fact that f is monotonic increasing in i if and only if its complement is monotonic decreasing in i.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Decreasing">Cudd_Decreasing</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_IndicesToCube"><b>Cudd_IndicesToCube</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int * <b>array</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Builds a cube of BDD variables from an array of indices. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddComputeCube">Cudd_bddComputeCube</a>
<a href="cuddAllDet.html#Cudd_CubeArrayToBdd">Cudd_CubeArrayToBdd</a>
</code>

<dt><pre>
DdManager * <i></i>
<a name="Cudd_Init"><b>Cudd_Init</b></a>(
  unsigned int  <b>numVars</b>, <i>initial number of BDD variables (i.e., subtables)</i>
  unsigned int  <b>numVarsZ</b>, <i>initial number of ZDD variables (i.e., subtables)</i>
  unsigned int  <b>numSlots</b>, <i>initial size of the unique tables</i>
  unsigned int  <b>cacheSize</b>, <i>initial size of the cache</i>
  unsigned long  <b>maxMemory</b> <i>target maximum memory occupation</i>
)
</pre>
<dd> Creates a new DD manager, initializes the table, the basic constants and the projection functions. If maxMemory is 0, Cudd_Init decides suitable values for the maximum size of the cache and for the limit for fast unique table growth based on the available memory. Returns a pointer to the manager if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Quit">Cudd_Quit</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_IsComplement"><b>Cudd_IsComplement</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns 1 if a pointer is complemented.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Regular">Cudd_Regular</a>
<a href="cuddAllDet.html#Cudd_Complement">Cudd_Complement</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_IsConstant"><b>Cudd_IsConstant</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns 1 if the node is a constant node (rather than an internal node). All constant nodes have the same index (CUDD_CONST_INDEX). The pointer passed to Cudd_IsConstant may be either regular or complemented.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
int <i></i>
<a name="Cudd_IsGenEmpty"><b>Cudd_IsGenEmpty</b></a>(
  DdGen * <b>gen</b> <i></i>
)
</pre>
<dd> Queries the status of a generator. Returns 1 if the generator is empty or NULL; 0 otherswise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="cuddAllDet.html#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="cuddAllDet.html#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="cuddAllDet.html#Cudd_NextCube">Cudd_NextCube</a>
<a href="cuddAllDet.html#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="cuddAllDet.html#Cudd_NextNode">Cudd_NextNode</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_IsInHook"><b>Cudd_IsInHook</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DD_HFP  <b>f</b>, <i></i>
  Cudd_HookType  <b>where</b> <i></i>
)
</pre>
<dd> Checks whether a function is in a hook. A hook is a list of application-provided functions called on certain occasions by the package. Returns 1 if the function is found; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AddHook">Cudd_AddHook</a>
<a href="cuddAllDet.html#Cudd_RemoveHook">Cudd_RemoveHook</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_IsNonConstant"><b>Cudd_IsNonConstant</b></a>(
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns 1 if a DD node is not constant. This function is useful to test the results of Cudd_bddIteConstant, Cudd_addIteConstant, Cudd_addEvalConst. These results may be a special value signifying non-constant. In the other cases the macro Cudd_IsConstant can be used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_IsConstant">Cudd_IsConstant</a>
<a href="cuddAllDet.html#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
<a href="cuddAllDet.html#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="cuddAllDet.html#Cudd_addEvalConst">Cudd_addEvalConst</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_IterDerefBdd"><b>Cudd_IterDerefBdd</b></a>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Decreases the reference count of node n. If n dies, recursively decreases the reference counts of its children. It is used to dispose of a BDD that is no longer needed. It is more efficient than Cudd_RecursiveDeref, but it cannot be used on ADDs. The greater efficiency comes from being able to assume that no constant node will ever die as a result of a call to this procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="cuddAllDet.html#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_LargestCube"><b>Cudd_LargestCube</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>length</b> <i></i>
)
</pre>
<dd> Finds a largest cube in a DD. f is the DD we want to get the largest cube for. The problem is translated into the one of finding a shortest path in f, when both THEN and ELSE arcs are assumed to have unit length. This yields a largest cube in the disjoint cover corresponding to the DD. Therefore, it is not necessarily the largest implicant of f. Returns the largest cube as a BDD.
<p>

<dd> <b>Side Effects</b> The number of literals of the cube is returned in length.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ShortestPath">Cudd_ShortestPath</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_MakeBddFromZddCover"><b>Cudd_MakeBddFromZddCover</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Converts a ZDD cover to a BDD graph. If successful, it returns a BDD node, otherwise it returns NULL.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddMakeBddFromZddCover">cuddMakeBddFromZddCover</a>
</code>

<dt><pre>
MtrNode * <i></i>
<a name="Cudd_MakeTreeNode"><b>Cudd_MakeTreeNode</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  unsigned int  <b>low</b>, <i>index of the first group variable</i>
  unsigned int  <b>size</b>, <i>number of variables in the group</i>
  unsigned int  <b>type</b> <i>MTR_DEFAULT or MTR_FIXED</i>
)
</pre>
<dd> Creates a new variable group. The group starts at variable and contains size variables. The parameter low is the index of the first variable. If the variable already exists, its current position in the order is known to the manager. If the variable does not exist yet, the position is assumed to be the same as the index. The group tree is created if it does not exist yet. Returns a pointer to the group if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The variable tree is changed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_MakeZddTreeNode">Cudd_MakeZddTreeNode</a>
</code>

<dt><pre>
MtrNode * <i></i>
<a name="Cudd_MakeZddTreeNode"><b>Cudd_MakeZddTreeNode</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  unsigned int  <b>low</b>, <i>index of the first group variable</i>
  unsigned int  <b>size</b>, <i>number of variables in the group</i>
  unsigned int  <b>type</b> <i>MTR_DEFAULT or MTR_FIXED</i>
)
</pre>
<dd> Creates a new ZDD variable group. The group starts at variable and contains size variables. The parameter low is the index of the first variable. If the variable already exists, its current position in the order is known to the manager. If the variable does not exist yet, the position is assumed to be the same as the index. The group tree is created if it does not exist yet. Returns a pointer to the group if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The ZDD variable tree is changed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_MakeTreeNode">Cudd_MakeTreeNode</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_MinHammingDist"><b>Cudd_MinHammingDist</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>function to examine</i>
  int * <b>minterm</b>, <i>reference minterm</i>
  int  <b>upperBound</b> <i>distance above which an approximate answer is OK</i>
)
</pre>
<dd> Returns the minimum Hamming distance between the minterms of a function f and a reference minterm. The function is given as a BDD; the minterm is given as an array of integers, one for each variable in the manager. Returns the minimum distance if it is less than the upper bound; the upper bound if the minimum distance is at least as large; CUDD_OUT_OF_MEM in case of failure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addHamming">Cudd_addHamming</a>
<a href="cuddAllDet.html#Cudd_bddClosestCube">Cudd_bddClosestCube</a>
</code>

<dt><pre>
DdApaNumber <i></i>
<a name="Cudd_NewApaNumber"><b>Cudd_NewApaNumber</b></a>(
  int  <b>digits</b> <i></i>
)
</pre>
<dd> Allocates memory for an arbitrary precision integer. Returns a pointer to the allocated memory if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_NextCube"><b>Cudd_NextCube</b></a>(
  DdGen * <b>gen</b>, <i></i>
  int ** <b>cube</b>, <i></i>
  CUDD_VALUE_TYPE * <b>value</b> <i></i>
)
</pre>
<dd> Generates the next cube of a decision diagram onset, using generator gen. Returns 0 if the enumeration is completed; 1 otherwise.
<p>

<dd> <b>Side Effects</b> The cube and its value are returned as side effects. The generator is modified.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="cuddAllDet.html#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_NextNode">Cudd_NextNode</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_NextNode"><b>Cudd_NextNode</b></a>(
  DdGen * <b>gen</b>, <i></i>
  DdNode ** <b>node</b> <i></i>
)
</pre>
<dd> Finds the node of a decision diagram, using generator gen. Returns 0 if the enumeration is completed; 1 otherwise.
<p>

<dd> <b>Side Effects</b> The next node is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="cuddAllDet.html#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_NextCube">Cudd_NextCube</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_NextPrime"><b>Cudd_NextPrime</b></a>(
  DdGen * <b>gen</b>, <i></i>
  int ** <b>cube</b> <i></i>
)
</pre>
<dd> Generates the next cube of a Boolean function, using generator gen. Returns 0 if the enumeration is completed; 1 otherwise.
<p>

<dd> <b>Side Effects</b> The cube and is returned as side effects. The generator is modified.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ForeachPrime">Cudd_ForeachPrime</a>
<a href="cuddAllDet.html#Cudd_FirstPrime">Cudd_FirstPrime</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_NextCube">Cudd_NextCube</a>
<a href="cuddAllDet.html#Cudd_NextNode">Cudd_NextNode</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_NodeReadIndex"><b>Cudd_NodeReadIndex</b></a>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Returns the index of the node. The node pointer can be either regular or complemented.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadIndex">Cudd_ReadIndex</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_NotCond"><b>Cudd_NotCond</b></a>(
   <b>node</b>, <i></i>
   <b>c</b> <i></i>
)
</pre>
<dd> Complements a DD if condition c is true; c should be either 0 or 1, because it is used directly (for efficiency). If in doubt on the values c may take, use "(c) ? Cudd_Not(node) : node".
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Not">Cudd_Not</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_Not"><b>Cudd_Not</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Complements a DD by flipping the complement attribute of the pointer (the least significant bit).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_NotCond">Cudd_NotCond</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_OutOfMem"><b>Cudd_OutOfMem</b></a>(
  long  <b>size</b> <i>size of the allocation that failed</i>
)
</pre>
<dd> Warns that a memory allocation failed. This function can be used as replacement of MMout_of_memory to prevent the safe_mem functions of the util package from exiting when malloc returns NULL. One possible use is in case of discretionary allocations; for instance, the allocation of memory to enlarge the computed table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_OverApprox"><b>Cudd_OverApprox</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. Returns a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_Prime"><b>Cudd_Prime</b></a>(
  unsigned int  <b>p</b> <i></i>
)
</pre>
<dd> Returns the next prime &gt;= p.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_PrintDebug"><b>Cudd_PrintDebug</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>n</b>, <i></i>
  int  <b>pr</b> <i></i>
)
</pre>
<dd> Prints to the standard output a DD and its statistics. The statistics include the number of nodes, the number of leaves, and the number of minterms. (The number of minterms is the number of assignments to the variables that cause the function to be different from the logical zero (for BDDs) and from the background value (for ADDs.) The statistics are printed if pr &gt; 0. Specifically: <ul> <li> pr = 0 : prints nothing <li> pr = 1 : prints counts of nodes and minterms <li> pr = 2 : prints counts + disjoint sum of product <li> pr = 3 : prints counts + list of nodes <li> pr &gt; 3 : prints counts + disjoint sum of product + list of nodes </ul> For the purpose of counting the number of minterms, the function is supposed to depend on n variables. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DagSize">Cudd_DagSize</a>
<a href="cuddAllDet.html#Cudd_CountLeaves">Cudd_CountLeaves</a>
<a href="cuddAllDet.html#Cudd_CountMinterm">Cudd_CountMinterm</a>
<a href="cuddAllDet.html#Cudd_PrintMinterm">Cudd_PrintMinterm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_PrintInfo"><b>Cudd_PrintInfo</b></a>(
  DdManager * <b>dd</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints out statistics and settings for a CUDD manager. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_PrintLinear"><b>Cudd_PrintLinear</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prints the linear transform matrix. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
int <i></i>
<a name="Cudd_PrintMinterm"><b>Cudd_PrintMinterm</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Prints a disjoint sum of product cover for the function rooted at node. Each product corresponds to a path from node to a leaf node different from the logical zero, and different from the background value. Uses the package default output file. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="cuddAllDet.html#Cudd_bddPrintCover">Cudd_bddPrintCover</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_PrintTwoLiteralClauses"><b>Cudd_PrintTwoLiteralClauses</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  char ** <b>names</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints the one- and two-literal clauses. Returns 1 if successful; 0 otherwise. The argument "names" can be NULL, in which case the variable indices are printed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_FindTwoLiteralClauses">Cudd_FindTwoLiteralClauses</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_PrintVersion"><b>Cudd_PrintVersion</b></a>(
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints the package version number.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_PrioritySelect"><b>Cudd_PrioritySelect</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>R</b>, <i>BDD of the relation</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b>, <i>array of y variables</i>
  DdNode ** <b>z</b>, <i>array of z variables (optional: may be NULL)</i>
  DdNode * <b>Pi</b>, <i>BDD of the priority function (optional: may be NULL)</i>
  int  <b>n</b>, <i>size of x, y, and z</i>
  DD_PRFP  <b>Pifunc</b> <i>function used to build Pi if it is NULL</i>
)
</pre>
<dd> Selects pairs from a relation R(x,y) (given as a BDD) in such a way that a given x appears in one pair only. Uses a priority function to determine which y should be paired to a given x. Cudd_PrioritySelect returns a pointer to the selected function if successful; NULL otherwise. Three of the arguments--x, y, and z--are vectors of BDD variables. The first two are the variables on which R depends. The third vectore is a vector of auxiliary variables, used during the computation. This vector is optional. If a NULL value is passed instead, Cudd_PrioritySelect will create the working variables on the fly. The sizes of x and y (and z if it is not NULL) should equal n. The priority function Pi can be passed as a BDD, or can be built by Cudd_PrioritySelect. If NULL is passed instead of a DdNode *, parameter Pifunc is used by Cudd_PrioritySelect to build a BDD for the priority function. (Pifunc is a pointer to a C function.) If Pi is not NULL, then Pifunc is ignored. Pifunc should have the same interface as the standard priority functions (e.g., Cudd_Dxygtdxz). Cudd_PrioritySelect and Cudd_CProjection can sometimes be used interchangeably. Specifically, calling Cudd_PrioritySelect with Cudd_Xgty as Pifunc produces the same result as calling Cudd_CProjection with the all-zero minterm as reference minterm. However, depending on the application, one or the other may be preferable: <ul> <li> When extracting representatives from an equivalence relation, Cudd_CProjection has the advantage of nor requiring the auxiliary variables. <li> When computing matchings in general bipartite graphs, Cudd_PrioritySelect normally obtains better results because it can use more powerful matching schemes (e.g., Cudd_Dxygtdxz). </ul>
<p>

<dd> <b>Side Effects</b> If called with z == NULL, will create new variables in the manager.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="cuddAllDet.html#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
<a href="cuddAllDet.html#Cudd_Xgty">Cudd_Xgty</a>
<a href="cuddAllDet.html#Cudd_bddAdjPermuteX">Cudd_bddAdjPermuteX</a>
<a href="cuddAllDet.html#Cudd_CProjection">Cudd_CProjection</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_Quit"><b>Cudd_Quit</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Deletes resources associated with a DD manager and resets the global statistical counters. (Otherwise, another manaqger subsequently created would inherit the stats of this one.)
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Init">Cudd_Init</a>
</code>

<dt><pre>
long <i></i>
<a name="Cudd_Random"><b>Cudd_Random</b></a>(
   <b></b> <i></i>
)
</pre>
<dd> Portable number generator based on ran2 from "Numerical Recipes in C." It is a long period (> 2 * 10^18) random number generator of L'Ecuyer with Bays-Durham shuffle. Returns a long integer uniformly distributed between 0 and 2147483561 (inclusive of the endpoint values). The random generator can be explicitly initialized by calling Cudd_Srandom. If no explicit initialization is performed, then the seed 1 is assumed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Srandom">Cudd_Srandom</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadArcviolation"><b>Cudd_ReadArcviolation</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the current value of the arcviolation parameter. This parameter is used in group sifting to decide how many arcs into <code>y</code> not coming from <code>x</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetArcviolation">Cudd_SetArcviolation</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadBackground"><b>Cudd_ReadBackground</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the background constant of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
double <i></i>
<a name="Cudd_ReadCacheHits"><b>Cudd_ReadCacheHits</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of cache hits.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadCacheLookUps">Cudd_ReadCacheLookUps</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadCacheLookUps"><b>Cudd_ReadCacheLookUps</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of cache look-ups.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadCacheHits">Cudd_ReadCacheHits</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadCacheSlots"><b>Cudd_ReadCacheSlots</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the number of slots in the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadCacheUsedSlots">Cudd_ReadCacheUsedSlots</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadCacheUsedSlots"><b>Cudd_ReadCacheUsedSlots</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the fraction of used slots in the cache. The unused slots are those in which no valid data is stored. Garbage collection, variable reordering, and cache resizing may cause used slots to become unused.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadCacheSlots">Cudd_ReadCacheSlots</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadDead"><b>Cudd_ReadDead</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of dead nodes in the unique table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadKeys">Cudd_ReadKeys</a>
</code>

<dt><pre>
CUDD_VALUE_TYPE <i></i>
<a name="Cudd_ReadEpsilon"><b>Cudd_ReadEpsilon</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the epsilon parameter of the manager. The epsilon parameter control the comparison between floating point numbers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetEpsilon">Cudd_SetEpsilon</a>
</code>

<dt><pre>
Cudd_ErrorType <i></i>
<a name="Cudd_ReadErrorCode"><b>Cudd_ReadErrorCode</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the code of the last error. The error codes are defined in cudd.h.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ClearErrorCode">Cudd_ClearErrorCode</a>
</code>

<dt><pre>
long <i></i>
<a name="Cudd_ReadGarbageCollectionTime"><b>Cudd_ReadGarbageCollectionTime</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of milliseconds spent doing garbage collection since the manager was initialized.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadGarbageCollections">Cudd_ReadGarbageCollections</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadGarbageCollections"><b>Cudd_ReadGarbageCollections</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of times garbage collection has occurred in the manager. The number includes both the calls from reordering procedures and those caused by requests to create new nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadGarbageCollectionTime">Cudd_ReadGarbageCollectionTime</a>
</code>

<dt><pre>
Cudd_AggregationType <i></i>
<a name="Cudd_ReadGroupcheck"><b>Cudd_ReadGroupcheck</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the groupcheck parameter of the manager. The groupcheck parameter determines the aggregation criterion in group sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetGroupcheck">Cudd_SetGroupcheck</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_ReadIndex"><b>Cudd_ReadIndex</b></a>(
   <b>dd</b>, <i></i>
   <b>index</b> <i></i>
)
</pre>
<dd> Returns the current position in the order of variable index. This macro is obsolete and is kept for compatibility. New applications should use Cudd_ReadPerm instead.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadInvPermZdd"><b>Cudd_ReadInvPermZdd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the index of the ZDD variable currently in the i-th position of the order. If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPerm">Cudd_ReadPerm</a>
<a href="cuddAllDet.html#Cudd_ReadInvPermZdd">Cudd_ReadInvPermZdd</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadInvPerm"><b>Cudd_ReadInvPerm</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the index of the variable currently in the i-th position of the order. If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPerm">Cudd_ReadPerm</a>
<a href="cuddAllDet.html#Cudd_ReadInvPermZdd">Cudd_ReadInvPermZdd</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadIthClause"><b>Cudd_ReadIthClause</b></a>(
  DdTlcInfo * <b>tlc</b>, <i></i>
  int  <b>i</b>, <i></i>
  DdHalfWord * <b>var1</b>, <i></i>
  DdHalfWord * <b>var2</b>, <i></i>
  int * <b>phase1</b>, <i></i>
  int * <b>phase2</b> <i></i>
)
</pre>
<dd> Accesses the i-th clause of a DD given the clause set which must be already computed. Returns 1 if successful; 0 if i is out of range, or in case of error.
<p>

<dd> <b>Side Effects</b> the four components of a clause are returned as side effects.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_FindTwoLiteralClauses">Cudd_FindTwoLiteralClauses</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadKeys"><b>Cudd_ReadKeys</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the total number of nodes currently in the unique table, including the dead nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadDead">Cudd_ReadDead</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadLinear"><b>Cudd_ReadLinear</b></a>(
  DdManager * <b>table</b>, <i>CUDD manager</i>
  int  <b>x</b>, <i>row index</i>
  int  <b>y</b> <i>column index</i>
)
</pre>
<dd> Reads an entry of the linear transform matrix.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadLogicZero"><b>Cudd_ReadLogicZero</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the zero constant of the manager. The logic zero constant is the complement of the one constant, and is distinct from the arithmetic zero.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadOne">Cudd_ReadOne</a>
<a href="cuddAllDet.html#Cudd_ReadZero">Cudd_ReadZero</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadLooseUpTo"><b>Cudd_ReadLooseUpTo</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the looseUpTo parameter of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetLooseUpTo">Cudd_SetLooseUpTo</a>
<a href="cuddAllDet.html#Cudd_ReadMinHit">Cudd_ReadMinHit</a>
<a href="cuddAllDet.html#Cudd_ReadMinDead">Cudd_ReadMinDead</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadMaxCacheHard"><b>Cudd_ReadMaxCacheHard</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maxCacheHard parameter of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetMaxCacheHard">Cudd_SetMaxCacheHard</a>
<a href="cuddAllDet.html#Cudd_ReadMaxCache">Cudd_ReadMaxCache</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadMaxCache"><b>Cudd_ReadMaxCache</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the soft limit for the cache size. The soft limit
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxCache">Cudd_ReadMaxCache</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadMaxGrowthAlternate"><b>Cudd_ReadMaxGrowthAlternate</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maxGrowthAlt parameter of the manager. This parameter is analogous to the maxGrowth paramter, and is used every given number of reorderings instead of maxGrowth. The number of reorderings is set with Cudd_SetReorderingCycle. If the number of reorderings is 0 (default) maxGrowthAlt is never used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxGrowth">Cudd_ReadMaxGrowth</a>
<a href="cuddAllDet.html#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
<a href="cuddAllDet.html#Cudd_SetReorderingCycle">Cudd_SetReorderingCycle</a>
<a href="cuddAllDet.html#Cudd_ReadReorderingCycle">Cudd_ReadReorderingCycle</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadMaxGrowth"><b>Cudd_ReadMaxGrowth</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maxGrowth parameter of the manager. This parameter determines how much the number of nodes can grow during sifting of a variable. Overall, sifting never increases the size of the decision diagrams. This parameter only refers to intermediate results. A lower value will speed up sifting, possibly at the expense of quality.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetMaxGrowth">Cudd_SetMaxGrowth</a>
<a href="cuddAllDet.html#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadMaxLive"><b>Cudd_ReadMaxLive</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maximum allowed number of live nodes. When this number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetMaxLive">Cudd_SetMaxLive</a>
</code>

<dt><pre>
unsigned long <i></i>
<a name="Cudd_ReadMaxMemory"><b>Cudd_ReadMaxMemory</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maximum allowed memory. When this number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetMaxMemory">Cudd_SetMaxMemory</a>
</code>

<dt><pre>
unsigned long <i></i>
<a name="Cudd_ReadMemoryInUse"><b>Cudd_ReadMemoryInUse</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the memory in use by the manager measured in bytes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadMinDead"><b>Cudd_ReadMinDead</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the minDead parameter of the manager. The minDead parameter is used by the package to decide whether to collect garbage or resize a subtable of the unique table when the subtable becomes too full. The application can indirectly control the value of minDead by setting the looseUpTo parameter.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadDead">Cudd_ReadDead</a>
<a href="cuddAllDet.html#Cudd_ReadLooseUpTo">Cudd_ReadLooseUpTo</a>
<a href="cuddAllDet.html#Cudd_SetLooseUpTo">Cudd_SetLooseUpTo</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadMinHit"><b>Cudd_ReadMinHit</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the hit rate that causes resizinig of the computed table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetMinHit">Cudd_SetMinHit</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadMinusInfinity"><b>Cudd_ReadMinusInfinity</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the minus-infinity constant from the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadNextReordering"><b>Cudd_ReadNextReordering</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the threshold for the next dynamic reordering. The threshold is in terms of number of nodes and is in effect only if reordering is enabled. The count does not include the dead nodes, unless the countDead parameter of the manager has been changed from its default setting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetNextReordering">Cudd_SetNextReordering</a>
</code>

<dt><pre>
long <i></i>
<a name="Cudd_ReadNodeCount"><b>Cudd_ReadNodeCount</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the number of live nodes in BDDs and ADDs. This number does not include the isolated projection functions and the unused constants. These nodes that are not counted are not part of the DDs manipulated by the application.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPeakNodeCount">Cudd_ReadPeakNodeCount</a>
<a href="cuddAllDet.html#Cudd_zddReadNodeCount">Cudd_zddReadNodeCount</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadNodesDropped"><b>Cudd_ReadNodesDropped</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of nodes killed by dereferencing if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_STATS defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadNodesFreed">Cudd_ReadNodesFreed</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadNodesFreed"><b>Cudd_ReadNodesFreed</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of nodes returned to the free list if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_STATS defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadNodesDropped">Cudd_ReadNodesDropped</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadNumberXovers"><b>Cudd_ReadNumberXovers</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the current number of crossovers used by the genetic algorithm for variable reordering. A larger number of crossovers will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as number of crossovers, with a maximum of 60.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetNumberXovers">Cudd_SetNumberXovers</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadOne"><b>Cudd_ReadOne</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the one constant of the manager. The one constant is common to ADDs and BDDs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadZero">Cudd_ReadZero</a>
<a href="cuddAllDet.html#Cudd_ReadLogicZero">Cudd_ReadLogicZero</a>
<a href="cuddAllDet.html#Cudd_ReadZddOne">Cudd_ReadZddOne</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadPeakLiveNodeCount"><b>Cudd_ReadPeakLiveNodeCount</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the peak number of live nodes. This count is kept only if CUDD is compiled with DD_STATS defined. If DD_STATS is not defined, this function returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadNodeCount">Cudd_ReadNodeCount</a>
<a href="cuddAllDet.html#Cudd_PrintInfo">Cudd_PrintInfo</a>
<a href="cuddAllDet.html#Cudd_ReadPeakNodeCount">Cudd_ReadPeakNodeCount</a>
</code>

<dt><pre>
long <i></i>
<a name="Cudd_ReadPeakNodeCount"><b>Cudd_ReadPeakNodeCount</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the peak number of nodes. This number includes node on the free list. At the peak, the number of nodes on the free list is guaranteed to be less than DD_MEM_CHUNK.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadNodeCount">Cudd_ReadNodeCount</a>
<a href="cuddAllDet.html#Cudd_PrintInfo">Cudd_PrintInfo</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadPermZdd"><b>Cudd_ReadPermZdd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the current position of the i-th ZDD variable in the order. If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadInvPermZdd">Cudd_ReadInvPermZdd</a>
<a href="cuddAllDet.html#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadPerm"><b>Cudd_ReadPerm</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the current position of the i-th variable in the order. If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadInvPerm">Cudd_ReadInvPerm</a>
<a href="cuddAllDet.html#Cudd_ReadPermZdd">Cudd_ReadPermZdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadPlusInfinity"><b>Cudd_ReadPlusInfinity</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the plus-infinity constant from the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ReadPopulationSize"><b>Cudd_ReadPopulationSize</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the current size of the population used by the genetic algorithm for variable reordering. A larger population size will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as population size, with a maximum of 120.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetPopulationSize">Cudd_SetPopulationSize</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadRecomb"><b>Cudd_ReadRecomb</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the current value of the recombination parameter used in group sifting. A larger (positive) value makes the aggregation of variables due to the second difference criterion more likely. A smaller (negative) value makes aggregation less likely.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetRecomb">Cudd_SetRecomb</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadRecursiveCalls"><b>Cudd_ReadRecursiveCalls</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of recursive calls if the package is compiled with DD_COUNT defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ReadReorderingCycle"><b>Cudd_ReadReorderingCycle</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the reordCycle parameter of the manager. This parameter determines how often the alternate threshold on maximum growth is used in reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
<a href="cuddAllDet.html#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
<a href="cuddAllDet.html#Cudd_SetReorderingCycle">Cudd_SetReorderingCycle</a>
</code>

<dt><pre>
long <i></i>
<a name="Cudd_ReadReorderingTime"><b>Cudd_ReadReorderingTime</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of milliseconds spent reordering variables since the manager was initialized. The time spent in collecting garbage before reordering is included.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadReorderings">Cudd_ReadReorderings</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadReorderings"><b>Cudd_ReadReorderings</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of times reordering has occurred in the manager. The number includes both the calls to Cudd_ReduceHeap from the application program and those automatically performed by the package. However, calls that do not even initiate reordering are not counted. A call may not initiate reordering if there are fewer than minsize live nodes in the manager, or if CUDD_REORDER_NONE is specified as reordering method. The calls to Cudd_ShuffleHeap are not counted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
<a href="cuddAllDet.html#Cudd_ReadReorderingTime">Cudd_ReadReorderingTime</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadSiftMaxSwap"><b>Cudd_ReadSiftMaxSwap</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the siftMaxSwap parameter of the manager. This parameter gives the maximum number of swaps that will be attempted for each invocation of sifting. The real number of swaps may exceed the set limit because the package will always complete the sifting of the variable that causes the limit to be reached.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadSiftMaxVar">Cudd_ReadSiftMaxVar</a>
<a href="cuddAllDet.html#Cudd_SetSiftMaxSwap">Cudd_SetSiftMaxSwap</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadSiftMaxVar"><b>Cudd_ReadSiftMaxVar</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the siftMaxVar parameter of the manager. This parameter gives the maximum number of variables that will be sifted for each invocation of sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadSiftMaxSwap">Cudd_ReadSiftMaxSwap</a>
<a href="cuddAllDet.html#Cudd_SetSiftMaxVar">Cudd_SetSiftMaxVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadSize"><b>Cudd_ReadSize</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of BDD variables in existance.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadZddSize">Cudd_ReadZddSize</a>
</code>

<dt><pre>
unsigned int <i></i>
<a name="Cudd_ReadSlots"><b>Cudd_ReadSlots</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the total number of slots of the unique table. This number ismainly for diagnostic purposes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
FILE * <i></i>
<a name="Cudd_ReadStderr"><b>Cudd_ReadStderr</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the stderr of a manager. This is the file pointer to which messages normally going to stderr are written. It is initialized to stderr. Cudd_SetStderr allows the application to redirect it.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetStderr">Cudd_SetStderr</a>
<a href="cuddAllDet.html#Cudd_ReadStdout">Cudd_ReadStdout</a>
</code>

<dt><pre>
FILE * <i></i>
<a name="Cudd_ReadStdout"><b>Cudd_ReadStdout</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the stdout of a manager. This is the file pointer to which messages normally going to stdout are written. It is initialized to stdout. Cudd_SetStdout allows the application to redirect it.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetStdout">Cudd_SetStdout</a>
<a href="cuddAllDet.html#Cudd_ReadStderr">Cudd_ReadStderr</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadSwapSteps"><b>Cudd_ReadSwapSteps</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the number of elementary reordering steps.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
int <i></i>
<a name="Cudd_ReadSymmviolation"><b>Cudd_ReadSymmviolation</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the current value of the symmviolation parameter. This parameter is used in group sifting to decide how many violations to the symmetry conditions <code>f10 = f01</code> or <code>f11 = f00</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetSymmviolation">Cudd_SetSymmviolation</a>
</code>

<dt><pre>
MtrNode * <i></i>
<a name="Cudd_ReadTree"><b>Cudd_ReadTree</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetTree">Cudd_SetTree</a>
<a href="cuddAllDet.html#Cudd_FreeTree">Cudd_FreeTree</a>
<a href="cuddAllDet.html#Cudd_ReadZddTree">Cudd_ReadZddTree</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadUniqueLinks"><b>Cudd_ReadUniqueLinks</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of links followed during look-ups in the unique table if the keeping of this statistic is enabled; -1 otherwise. If an item is found in the first position of its collision list, the number of links followed is taken to be 0. If it is in second position, the number of links is 1, and so on. This statistic is enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadUniqueLookUps">Cudd_ReadUniqueLookUps</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadUniqueLookUps"><b>Cudd_ReadUniqueLookUps</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of look-ups in the unique table if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadUniqueLinks">Cudd_ReadUniqueLinks</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_ReadUsedSlots"><b>Cudd_ReadUsedSlots</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the fraction of used slots in the unique table. The unused slots are those in which no valid data is stored. Garbage collection, variable reordering, and subtable resizing may cause used slots to become unused.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadSlots">Cudd_ReadSlots</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadVars"><b>Cudd_ReadVars</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the i-th element of the vars array if it falls within the array bounds; NULL otherwise. If i is the index of an existing variable, this function produces the same result as Cudd_bddIthVar. However, if the i-th var does not exist yet, Cudd_bddIthVar will create it, whereas Cudd_ReadVars will not.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIthVar">Cudd_bddIthVar</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadZddOne"><b>Cudd_ReadZddOne</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the ZDD for the constant 1 function. The representation of the constant 1 function as a ZDD depends on how many variables it (nominally) depends on. The index of the topmost variable in the support is given as argument <code>i</code>.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadOne">Cudd_ReadOne</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReadZddSize"><b>Cudd_ReadZddSize</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of ZDD variables in existance.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
MtrNode * <i></i>
<a name="Cudd_ReadZddTree"><b>Cudd_ReadZddTree</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetZddTree">Cudd_SetZddTree</a>
<a href="cuddAllDet.html#Cudd_FreeZddTree">Cudd_FreeZddTree</a>
<a href="cuddAllDet.html#Cudd_ReadTree">Cudd_ReadTree</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ReadZero"><b>Cudd_ReadZero</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the zero constant of the manager. The zero constant is the arithmetic zero, rather than the logic zero. The latter is the complement of the one constant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadOne">Cudd_ReadOne</a>
<a href="cuddAllDet.html#Cudd_ReadLogicZero">Cudd_ReadLogicZero</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_RecursiveDerefZdd"><b>Cudd_RecursiveDerefZdd</b></a>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Decreases the reference count of ZDD node n. If n dies, recursively decreases the reference counts of its children. It is used to dispose of a ZDD that is no longer needed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Deref">Cudd_Deref</a>
<a href="cuddAllDet.html#Cudd_Ref">Cudd_Ref</a>
<a href="cuddAllDet.html#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_RecursiveDeref"><b>Cudd_RecursiveDeref</b></a>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Decreases the reference count of node n. If n dies, recursively decreases the reference counts of its children. It is used to dispose of a DD that is no longer needed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Deref">Cudd_Deref</a>
<a href="cuddAllDet.html#Cudd_Ref">Cudd_Ref</a>
<a href="cuddAllDet.html#Cudd_RecursiveDerefZdd">Cudd_RecursiveDerefZdd</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReduceHeap"><b>Cudd_ReduceHeap</b></a>(
  DdManager * <b>table</b>, <i>DD manager</i>
  Cudd_ReorderingType  <b>heuristic</b>, <i>method used for reordering</i>
  int  <b>minsize</b> <i>bound below which no reordering occurs</i>
)
</pre>
<dd> Main dynamic reordering routine. Calls one of the possible reordering procedures: <ul> <li>Swapping <li>Sifting <li>Symmetric Sifting <li>Group Sifting <li>Window Permutation <li>Simulated Annealing <li>Genetic Algorithm <li>Dynamic Programming (exact) </ul> For sifting, symmetric sifting, group sifting, and window permutation it is possible to request reordering to convergence.<p> The core of all methods is the reordering procedure cuddSwapInPlace() which swaps two adjacent variables and is based on Rudell's paper. Returns 1 in case of success; 0 otherwise. In the case of symmetric sifting (with and without convergence) returns 1 plus the number of symmetric variables, in case of success.
<p>

<dd> <b>Side Effects</b> Changes the variable order for all diagrams and clears the cache.
<p>

<dt><pre>
void <i></i>
<a name="Cudd_Ref"><b>Cudd_Ref</b></a>(
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Increases the reference count of a node, if it is not saturated.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="cuddAllDet.html#Cudd_Deref">Cudd_Deref</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_Regular"><b>Cudd_Regular</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the regular version of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Complement">Cudd_Complement</a>
<a href="cuddAllDet.html#Cudd_IsComplement">Cudd_IsComplement</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_RemapOverApprox"><b>Cudd_RemapOverApprox</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. Returns a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_RemapUnderApprox"><b>Cudd_RemapUnderApprox</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure uses a remapping technique and density as the cost function. Returns a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_UnderApprox">Cudd_UnderApprox</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_RemoveHook"><b>Cudd_RemoveHook</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DD_HFP  <b>f</b>, <i></i>
  Cudd_HookType  <b>where</b> <i></i>
)
</pre>
<dd> Removes a function from a hook. A hook is a list of application-provided functions called on certain occasions by the package. Returns 1 if successful; 0 the function was not in the list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AddHook">Cudd_AddHook</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReorderingReporting"><b>Cudd_ReorderingReporting</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns 1 if reporting of reordering stats is enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_EnableReorderingReporting">Cudd_EnableReorderingReporting</a>
<a href="cuddAllDet.html#Cudd_DisableReorderingReporting">Cudd_DisableReorderingReporting</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReorderingStatusZdd"><b>Cudd_ReorderingStatusZdd</b></a>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType * <b>method</b> <i></i>
)
</pre>
<dd> Reports the status of automatic dynamic reordering of ZDDs. Parameter method is set to the ZDD reordering method currently selected. Returns 1 if automatic reordering is enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Parameter method is set to the ZDD reordering method currently selected.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AutodynEnableZdd">Cudd_AutodynEnableZdd</a>
<a href="cuddAllDet.html#Cudd_AutodynDisableZdd">Cudd_AutodynDisableZdd</a>
<a href="cuddAllDet.html#Cudd_ReorderingStatus">Cudd_ReorderingStatus</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ReorderingStatus"><b>Cudd_ReorderingStatus</b></a>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType * <b>method</b> <i></i>
)
</pre>
<dd> Reports the status of automatic dynamic reordering of BDDs and ADDs. Parameter method is set to the reordering method currently selected. Returns 1 if automatic reordering is enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Parameter method is set to the reordering method currently selected.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_AutodynEnable">Cudd_AutodynEnable</a>
<a href="cuddAllDet.html#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
<a href="cuddAllDet.html#Cudd_ReorderingStatusZdd">Cudd_ReorderingStatusZdd</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetArcviolation"><b>Cudd_SetArcviolation</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>arcviolation</b> <i></i>
)
</pre>
<dd> Sets the value of the arcviolation parameter. This parameter is used in group sifting to decide how many arcs into <code>y</code> not coming from <code>x</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadArcviolation">Cudd_ReadArcviolation</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetBackground"><b>Cudd_SetBackground</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>bck</b> <i></i>
)
</pre>
<dd> Sets the background constant of the manager. It assumes that the DdNode pointer bck is already referenced.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="Cudd_SetEpsilon"><b>Cudd_SetEpsilon</b></a>(
  DdManager * <b>dd</b>, <i></i>
  CUDD_VALUE_TYPE  <b>ep</b> <i></i>
)
</pre>
<dd> Sets the epsilon parameter of the manager to ep. The epsilon parameter control the comparison between floating point numbers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadEpsilon">Cudd_ReadEpsilon</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetGroupcheck"><b>Cudd_SetGroupcheck</b></a>(
  DdManager * <b>dd</b>, <i></i>
  Cudd_AggregationType  <b>gc</b> <i></i>
)
</pre>
<dd> Sets the parameter groupcheck of the manager to gc. The groupcheck parameter determines the aggregation criterion in group sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadGroupCheck">Cudd_ReadGroupCheck</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetLooseUpTo"><b>Cudd_SetLooseUpTo</b></a>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>lut</b> <i></i>
)
</pre>
<dd> Sets the looseUpTo parameter of the manager. This parameter of the manager controls the threshold beyond which no fast growth of the unique table is allowed. The threshold is given as a number of slots. If the value passed to this function is 0, the function determines a suitable value based on the available memory.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadLooseUpTo">Cudd_ReadLooseUpTo</a>
<a href="cuddAllDet.html#Cudd_SetMinHit">Cudd_SetMinHit</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetMaxCacheHard"><b>Cudd_SetMaxCacheHard</b></a>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>mc</b> <i></i>
)
</pre>
<dd> Sets the maxCacheHard parameter of the manager. The cache cannot grow larger than maxCacheHard entries. This parameter allows an application to control the trade-off of memory versus speed. If the value passed to this function is 0, the function determines a suitable maximum cache size based on the available memory.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxCacheHard">Cudd_ReadMaxCacheHard</a>
<a href="cuddAllDet.html#Cudd_SetMaxCache">Cudd_SetMaxCache</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetMaxGrowthAlternate"><b>Cudd_SetMaxGrowthAlternate</b></a>(
  DdManager * <b>dd</b>, <i></i>
  double  <b>mg</b> <i></i>
)
</pre>
<dd> Sets the maxGrowthAlt parameter of the manager. This parameter is analogous to the maxGrowth paramter, and is used every given number of reorderings instead of maxGrowth. The number of reorderings is set with Cudd_SetReorderingCycle. If the number of reorderings is 0 (default) maxGrowthAlt is never used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
<a href="cuddAllDet.html#Cudd_SetMaxGrowth">Cudd_SetMaxGrowth</a>
<a href="cuddAllDet.html#Cudd_SetReorderingCycle">Cudd_SetReorderingCycle</a>
<a href="cuddAllDet.html#Cudd_ReadReorderingCycle">Cudd_ReadReorderingCycle</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetMaxGrowth"><b>Cudd_SetMaxGrowth</b></a>(
  DdManager * <b>dd</b>, <i></i>
  double  <b>mg</b> <i></i>
)
</pre>
<dd> Sets the maxGrowth parameter of the manager. This parameter determines how much the number of nodes can grow during sifting of a variable. Overall, sifting never increases the size of the decision diagrams. This parameter only refers to intermediate results. A lower value will speed up sifting, possibly at the expense of quality.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxGrowth">Cudd_ReadMaxGrowth</a>
<a href="cuddAllDet.html#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetMaxLive"><b>Cudd_SetMaxLive</b></a>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>maxLive</b> <i></i>
)
</pre>
<dd> Sets the maximum allowed number of live nodes. When this number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxLive">Cudd_ReadMaxLive</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetMaxMemory"><b>Cudd_SetMaxMemory</b></a>(
  DdManager * <b>dd</b>, <i></i>
  unsigned long  <b>maxMemory</b> <i></i>
)
</pre>
<dd> Sets the maximum allowed memory. When this number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxMemory">Cudd_ReadMaxMemory</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetMinHit"><b>Cudd_SetMinHit</b></a>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>hr</b> <i></i>
)
</pre>
<dd> Sets the minHit parameter of the manager. This parameter controls the resizing of the computed table. If the hit rate is larger than the specified value, and the cache is not already too large, then its size is doubled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMinHit">Cudd_ReadMinHit</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetNextReordering"><b>Cudd_SetNextReordering</b></a>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>next</b> <i></i>
)
</pre>
<dd> Sets the threshold for the next dynamic reordering. The threshold is in terms of number of nodes and is in effect only if reordering is enabled. The count does not include the dead nodes, unless the countDead parameter of the manager has been changed from its default setting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadNextReordering">Cudd_ReadNextReordering</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetNumberXovers"><b>Cudd_SetNumberXovers</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>numberXovers</b> <i></i>
)
</pre>
<dd> Sets the number of crossovers used by the genetic algorithm for variable reordering. A larger number of crossovers will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as number of crossovers, with a maximum of 60.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadNumberXovers">Cudd_ReadNumberXovers</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetPopulationSize"><b>Cudd_SetPopulationSize</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>populationSize</b> <i></i>
)
</pre>
<dd> Sets the size of the population used by the genetic algorithm for variable reordering. A larger population size will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as population size, with a maximum of 120.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPopulationSize">Cudd_ReadPopulationSize</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetRecomb"><b>Cudd_SetRecomb</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>recomb</b> <i></i>
)
</pre>
<dd> Sets the value of the recombination parameter used in group sifting. A larger (positive) value makes the aggregation of variables due to the second difference criterion more likely. A smaller (negative) value makes aggregation less likely. The default value is 0.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadRecomb">Cudd_ReadRecomb</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetReorderingCycle"><b>Cudd_SetReorderingCycle</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>cycle</b> <i></i>
)
</pre>
<dd> Sets the reordCycle parameter of the manager. This parameter determines how often the alternate threshold on maximum growth is used in reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
<a href="cuddAllDet.html#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
<a href="cuddAllDet.html#Cudd_ReadReorderingCycle">Cudd_ReadReorderingCycle</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetSiftMaxSwap"><b>Cudd_SetSiftMaxSwap</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>sms</b> <i></i>
)
</pre>
<dd> Sets the siftMaxSwap parameter of the manager. This parameter gives the maximum number of swaps that will be attempted for each invocation of sifting. The real number of swaps may exceed the set limit because the package will always complete the sifting of the variable that causes the limit to be reached.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetSiftMaxVar">Cudd_SetSiftMaxVar</a>
<a href="cuddAllDet.html#Cudd_ReadSiftMaxSwap">Cudd_ReadSiftMaxSwap</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetSiftMaxVar"><b>Cudd_SetSiftMaxVar</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>smv</b> <i></i>
)
</pre>
<dd> Sets the siftMaxVar parameter of the manager. This parameter gives the maximum number of variables that will be sifted for each invocation of sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SetSiftMaxSwap">Cudd_SetSiftMaxSwap</a>
<a href="cuddAllDet.html#Cudd_ReadSiftMaxVar">Cudd_ReadSiftMaxVar</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetStderr"><b>Cudd_SetStderr</b></a>(
  DdManager * <b>dd</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Sets the stderr of a manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadStderr">Cudd_ReadStderr</a>
<a href="cuddAllDet.html#Cudd_SetStdout">Cudd_SetStdout</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetStdout"><b>Cudd_SetStdout</b></a>(
  DdManager * <b>dd</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Sets the stdout of a manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadStdout">Cudd_ReadStdout</a>
<a href="cuddAllDet.html#Cudd_SetStderr">Cudd_SetStderr</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetSymmviolation"><b>Cudd_SetSymmviolation</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>symmviolation</b> <i></i>
)
</pre>
<dd> Sets the value of the symmviolation parameter. This parameter is used in group sifting to decide how many violations to the symmetry conditions <code>f10 = f01</code> or <code>f11 = f00</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadSymmviolation">Cudd_ReadSymmviolation</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetTree"><b>Cudd_SetTree</b></a>(
  DdManager * <b>dd</b>, <i></i>
  MtrNode * <b>tree</b> <i></i>
)
</pre>
<dd> Sets the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_FreeTree">Cudd_FreeTree</a>
<a href="cuddAllDet.html#Cudd_ReadTree">Cudd_ReadTree</a>
<a href="cuddAllDet.html#Cudd_SetZddTree">Cudd_SetZddTree</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_SetVarMap"><b>Cudd_SetVarMap</b></a>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdNode ** <b>x</b>, <i>first array of variables</i>
  DdNode ** <b>y</b>, <i>second array of variables</i>
  int  <b>n</b> <i>length of both arrays</i>
)
</pre>
<dd> Registers with the manager a variable mapping described by two sets of variables. This variable mapping is then used by functions like Cudd_bddVarMap. This function is convenient for those applications that perform the same mapping several times. However, if several different permutations are used, it may be more efficient not to rely on the registered mapping, because changing mapping causes the cache to be cleared. (The initial setting, however, does not clear the cache.) The two sets of variables (x and y) must have the same size (x and y). The size is given by n. The two sets of variables are normally disjoint, but this restriction is not imposeded by the function. When new variables are created, the map is automatically extended (each new variable maps to itself). The typical use, however, is to wait until all variables are created, and then create the map. Returns 1 if the mapping is successfully registered with the manager; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Modifies the manager. May clear the cache.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddVarMap">Cudd_bddVarMap</a>
<a href="cuddAllDet.html#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="cuddAllDet.html#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SetZddTree"><b>Cudd_SetZddTree</b></a>(
  DdManager * <b>dd</b>, <i></i>
  MtrNode * <b>tree</b> <i></i>
)
</pre>
<dd> Sets the ZDD variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_FreeZddTree">Cudd_FreeZddTree</a>
<a href="cuddAllDet.html#Cudd_ReadZddTree">Cudd_ReadZddTree</a>
<a href="cuddAllDet.html#Cudd_SetTree">Cudd_SetTree</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_SharingSize"><b>Cudd_SharingSize</b></a>(
  DdNode ** <b>nodeArray</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Counts the number of nodes in an array of DDs. Shared nodes are counted only once. Returns the total number of nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DagSize">Cudd_DagSize</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ShortestLength"><b>Cudd_ShortestLength</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>weight</b> <i></i>
)
</pre>
<dd> Find the length of the shortest path(s) in a DD. f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN edge coming from the node whose index is i. All ELSE edges have 0 weight. Returns the length of the shortest path(s) if successful; CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ShortestPath">Cudd_ShortestPath</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_ShortestPath"><b>Cudd_ShortestPath</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>weight</b>, <i></i>
  int * <b>support</b>, <i></i>
  int * <b>length</b> <i></i>
)
</pre>
<dd> Finds a shortest path in a DD. f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN arc coming from the node whose index is i. If weight is NULL, then unit weights are assumed for all THEN arcs. All ELSE arcs have 0 weight. If non-NULL, both weight and support should point to arrays with at least as many entries as there are variables in the manager. Returns the shortest path as the BDD of a cube.
<p>

<dd> <b>Side Effects</b> support contains on return the true support of f. If support is NULL on entry, then Cudd_ShortestPath does not compute the true support info. length contains the length of the path.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ShortestLength">Cudd_ShortestLength</a>
<a href="cuddAllDet.html#Cudd_LargestCube">Cudd_LargestCube</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_ShuffleHeap"><b>Cudd_ShuffleHeap</b></a>(
  DdManager * <b>table</b>, <i>DD manager</i>
  int * <b>permutation</b> <i>required variable permutation</i>
)
</pre>
<dd> Reorders variables according to given permutation. The i-th entry of the permutation array contains the index of the variable that should be brought to the i-th level. The size of the array should be equal or greater to the number of variables currently in use. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the variable order for all diagrams and clears the cache.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SolveEqn"><b>Cudd_SolveEqn</b></a>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode * <b>Y</b>, <i>the cube of the y variables</i>
  DdNode ** <b>G</b>, <i>the array of solutions (return parameter)</i>
  int ** <b>yIndex</b>, <i>index of y variables</i>
  int  <b>n</b> <i>numbers of unknowns</i>
)
</pre>
<dd> Implements the solution for F(x,y) = 0. The return value is the consistency condition. The y variables are the unknowns and the remaining variables are the parameters. Returns the consistency condition if successful; NULL otherwise. Cudd_SolveEqn allocates an array and fills it with the indices of the unknowns. This array is used by Cudd_VerifySol.
<p>

<dd> <b>Side Effects</b> The solution is returned in G; the indices of the y variables are returned in yIndex.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SplitSet"><b>Cudd_SplitSet</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>S</b>, <i></i>
  DdNode ** <b>xVars</b>, <i></i>
  int  <b>n</b>, <i></i>
  double  <b>m</b> <i></i>
)
</pre>
<dd> Returns <code>m</code> minterms from a BDD whose support has <code>n</code> variables at most. The procedure tries to create as few extra nodes as possible. The function represented by <code>S</code> depends on at most <code>n</code> of the variables in <code>xVars</code>. Returns a BDD with <code>m</code> minterms of the on-set of S if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="Cudd_Srandom"><b>Cudd_Srandom</b></a>(
  long  <b>seed</b> <i></i>
)
</pre>
<dd> Initializer for the portable number generator based on ran2 in "Numerical Recipes in C." The input is the seed for the generator. If it is negative, its absolute value is taken as seed. If it is 0, then 1 is taken as seed. The initialized sets up the two recurrences used to generate a long-period stream, and sets up the shuffle table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Random">Cudd_Random</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_StdPostReordHook"><b>Cudd_StdPostReordHook</b></a>(
  DdManager * <b>dd</b>, <i></i>
  const char * <b>str</b>, <i></i>
  void * <b>data</b> <i></i>
)
</pre>
<dd> Sample hook function to call after reordering. Prints on the manager's stdout final size and reordering time. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_StdPreReordHook">Cudd_StdPreReordHook</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_StdPreReordHook"><b>Cudd_StdPreReordHook</b></a>(
  DdManager * <b>dd</b>, <i></i>
  const char * <b>str</b>, <i></i>
  void * <b>data</b> <i></i>
)
</pre>
<dd> Sample hook function to call before reordering. Prints on the manager's stdout reordering method and initial size. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_StdPostReordHook">Cudd_StdPostReordHook</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SubsetCompress"><b>Cudd_SubsetCompress</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>BDD whose subset is sought</i>
  int  <b>nvars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the subset</i>
)
</pre>
<dd> Finds a dense subset of BDD <code>f</code>. Density is the ratio of number of minterms to number of nodes. Uses several techniques in series. It is more expensive than other subsetting procedures, but often produces better results. See Cudd_SubsetShortPaths for a description of the threshold and nvars parameters. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetRemap">Cudd_SubsetRemap</a>
<a href="cuddAllDet.html#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SubsetHeavyBranch"><b>Cudd_SubsetHeavyBranch</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the subset</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure builds a subset by throwing away one of the children of each node, starting from the root, until the result is small enough. The child that is eliminated from the result is the one that contributes the fewer minterms. Returns a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation and node count calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SubsetShortPaths"><b>Cudd_SubsetShortPaths</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>maximum number of nodes in the subset</i>
  int  <b>hardlimit</b> <i>flag: 1 if threshold is a hard limit</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure tries to preserve the shortest paths of the input BDD, because they give many minterms and contribute few nodes. This procedure may increase the number of nodes in trying to create the subset or reduce the number of nodes due to recombination as compared to the original BDD. Hence the threshold may not be strictly adhered to. In practice, recombination overshadows the increase in the number of nodes and results in small BDDs as compared to the threshold. The hardlimit specifies whether threshold needs to be strictly adhered to. If it is set to 1, the procedure ensures that result is never larger than the specified limit but may be considerably less than the threshold. Returns a pointer to the BDD for the subset if successful; NULL otherwise. The value for numVars should be as close as possible to the size of the support of f for better efficiency. However, it is safe to pass the value returned by Cudd_ReadSize for numVars. If 0 is passed, then the value returned by Cudd_ReadSize is used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SubsetWithMaskVars"><b>Cudd_SubsetWithMaskVars</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function from which to pick a cube</i>
  DdNode ** <b>vars</b>, <i>array of variables</i>
  int  <b>nvars</b>, <i>size of <code>vars</code></i>
  DdNode ** <b>maskVars</b>, <i>array of variables</i>
  int  <b>mvars</b> <i>size of <code>maskVars</code></i>
)
</pre>
<dd> Extracts a subset from a BDD in the following procedure. 1. Compute the weight for each mask variable by counting the number of minterms for both positive and negative cofactors of the BDD with respect to each mask variable. (weight = #positive - #negative) 2. Find a representative cube of the BDD by using the weight. From the top variable of the BDD, for each variable, if the weight is greater than 0.0, choose THEN branch, othereise ELSE branch, until meeting the constant 1. 3. Quantify out the variables not in maskVars from the representative cube and if a variable in maskVars is don't care, replace the variable with a constant(1 or 0) depending on the weight. 4. Make a subset of the BDD by multiplying with the modified cube.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SupersetCompress"><b>Cudd_SupersetCompress</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>BDD whose superset is sought</i>
  int  <b>nvars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the superset</i>
)
</pre>
<dd> Finds a dense superset of BDD <code>f</code>. Density is the ratio of number of minterms to number of nodes. Uses several techniques in series. It is more expensive than other supersetting procedures, but often produces better results. See Cudd_SupersetShortPaths for a description of the threshold and nvars parameters. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetCompress">Cudd_SubsetCompress</a>
<a href="cuddAllDet.html#Cudd_SupersetRemap">Cudd_SupersetRemap</a>
<a href="cuddAllDet.html#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SupersetHeavyBranch"><b>Cudd_SupersetHeavyBranch</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the superset</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is identical to the subset procedure except for the fact that it receives the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. This procedure builds a superset by throwing away one of the children of each node starting from the root of the complement function, until the result is small enough. The child that is eliminated from the result is the one that contributes the fewer minterms. Returns a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation and node count calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_SupersetShortPaths"><b>Cudd_SupersetShortPaths</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>maximum number of nodes in the subset</i>
  int  <b>hardlimit</b> <i>flag: 1 if threshold is a hard limit</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is identical to the subset procedure except for the fact that it receives the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. This procedure tries to preserve the shortest paths of the complement BDD, because they give many minterms and contribute few nodes. This procedure may increase the number of nodes in trying to create the superset or reduce the number of nodes due to recombination as compared to the original BDD. Hence the threshold may not be strictly adhered to. In practice, recombination overshadows the increase in the number of nodes and results in small BDDs as compared to the threshold. The hardlimit specifies whether threshold needs to be strictly adhered to. If it is set to 1, the procedure ensures that result is never larger than the specified limit but may be considerably less than the threshold. Returns a pointer to the BDD for the superset if successful; NULL otherwise. The value for numVars should be as close as possible to the size of the support of f for better efficiency. However, it is safe to pass the value returned by Cudd_ReadSize for numVar. If 0 is passed, then the value returned by Cudd_ReadSize is used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
int * <i></i>
<a name="Cudd_SupportIndex"><b>Cudd_SupportIndex</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b> <i>DD whose support is sought</i>
)
</pre>
<dd> Finds the variables on which a DD depends. Returns an index array of the variables if successful; NULL otherwise. The size of the array equals the number of variables in the manager. Each entry of the array is 1 if the corresponding variable is in the support of the DD and 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Support">Cudd_Support</a>
<a href="cuddAllDet.html#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="cuddAllDet.html#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_SupportSize"><b>Cudd_SupportSize</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b> <i>DD whose support size is sought</i>
)
</pre>
<dd> Counts the variables on which a DD depends. Returns the number of the variables if successful; CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Support">Cudd_Support</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Support"><b>Cudd_Support</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b> <i>DD whose support is sought</i>
)
</pre>
<dd> Finds the variables on which a DD depends. Returns a BDD consisting of the product of the variables if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="cuddAllDet.html#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_SymmProfile"><b>Cudd_SymmProfile</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Prints statistics on symmetric variables.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="Cudd_TurnOffCountDead"><b>Cudd_TurnOffCountDead</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Causes the dead nodes not to be counted towards triggering reordering. This causes less frequent reorderings. By default dead nodes are not counted. Therefore there is no need to call this function unless Cudd_TurnOnCountDead has been previously called.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_TurnOnCountDead">Cudd_TurnOnCountDead</a>
<a href="cuddAllDet.html#Cudd_DeadAreCounted">Cudd_DeadAreCounted</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_TurnOnCountDead"><b>Cudd_TurnOnCountDead</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Causes the dead nodes to be counted towards triggering reordering. This causes more frequent reorderings. By default dead nodes are not counted.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_TurnOffCountDead">Cudd_TurnOffCountDead</a>
<a href="cuddAllDet.html#Cudd_DeadAreCounted">Cudd_DeadAreCounted</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_T"><b>Cudd_T</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the then child of an internal node. If <code>node</code> is a constant node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_E">Cudd_E</a>
<a href="cuddAllDet.html#Cudd_V">Cudd_V</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_UnderApprox"><b>Cudd_UnderApprox</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure uses a variant of Tom Shiple's underapproximation method. The main difference from the original method is that density is used as cost function. Returns a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="cuddAllDet.html#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="cuddAllDet.html#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<dt><pre>
int * <i></i>
<a name="Cudd_VectorSupportIndex"><b>Cudd_VectorSupportIndex</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode ** <b>F</b>, <i>array of DDs whose support is sought</i>
  int  <b>n</b> <i>size of the array</i>
)
</pre>
<dd> Finds the variables on which a set of DDs depends. The set must contain either BDDs and ADDs, or ZDDs. Returns an index array of the variables if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SupportIndex">Cudd_SupportIndex</a>
<a href="cuddAllDet.html#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="cuddAllDet.html#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_VectorSupportSize"><b>Cudd_VectorSupportSize</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode ** <b>F</b>, <i>array of DDs whose support is sought</i>
  int  <b>n</b> <i>size of the array</i>
)
</pre>
<dd> Counts the variables on which a set of DDs depends. The set must contain either BDDs and ADDs, or ZDDs. Returns the number of the variables if successful; CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="cuddAllDet.html#Cudd_SupportSize">Cudd_SupportSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_VectorSupport"><b>Cudd_VectorSupport</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode ** <b>F</b>, <i>array of DDs whose support is sought</i>
  int  <b>n</b> <i>size of the array</i>
)
</pre>
<dd> Finds the variables on which a set of DDs depends. The set must contain either BDDs and ADDs, or ZDDs. Returns a BDD consisting of the product of the variables if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Support">Cudd_Support</a>
<a href="cuddAllDet.html#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_VerifySol"><b>Cudd_VerifySol</b></a>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int * <b>yIndex</b>, <i>index of y variables</i>
  int  <b>n</b> <i>numbers of unknowns</i>
)
</pre>
<dd> Checks the solution of F(x,y) = 0. This procedure substitutes the solution components for the unknowns of F and returns the resulting BDD for F.
<p>

<dd> <b>Side Effects</b> Frees the memory pointed by yIndex.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SolveEqn">Cudd_SolveEqn</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_V"><b>Cudd_V</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the value of a constant node. If <code>node</code> is an internal node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_T">Cudd_T</a>
<a href="cuddAllDet.html#Cudd_E">Cudd_E</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Xeqy"><b>Cudd_Xeqy</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates a BDD for the function x==y. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most significant bit. The BDD is built bottom-up. It has 3*N-1 internal nodes, if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addXeqy">Cudd_addXeqy</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_Xgty"><b>Cudd_Xgty</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  DdNode ** <b>z</b>, <i>array of z variables: unused</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates a BDD for the function x &gt; y. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most significant bit. The BDD is built bottom-up. It has 3*N-1 internal nodes, if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1]. Argument z is not used by Cudd_Xgty: it is included to make it call-compatible to Cudd_Dxygtdxz and Cudd_Dxygtdyz.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
<a href="cuddAllDet.html#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="cuddAllDet.html#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addAgreement"><b>Cudd_addAgreement</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Returns NULL if not a terminal case; f op g otherwise, where f op g is f if f==g; background if f!=g.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addApply"><b>Cudd_addApply</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DD_AOP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Applies op to the corresponding discriminants of f and g. Returns a pointer to the result if succssful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addMonadicApply">Cudd_addMonadicApply</a>
<a href="cuddAllDet.html#Cudd_addPlus">Cudd_addPlus</a>
<a href="cuddAllDet.html#Cudd_addTimes">Cudd_addTimes</a>
<a href="cuddAllDet.html#Cudd_addThreshold">Cudd_addThreshold</a>
<a href="cuddAllDet.html#Cudd_addSetNZ">Cudd_addSetNZ</a>
<a href="cuddAllDet.html#Cudd_addDivide">Cudd_addDivide</a>
<a href="cuddAllDet.html#Cudd_addMinus">Cudd_addMinus</a>
<a href="cuddAllDet.html#Cudd_addMinimum">Cudd_addMinimum</a>
<a href="cuddAllDet.html#Cudd_addMaximum">Cudd_addMaximum</a>
<a href="cuddAllDet.html#Cudd_addOneZeroMaximum">Cudd_addOneZeroMaximum</a>
<a href="cuddAllDet.html#Cudd_addDiff">Cudd_addDiff</a>
<a href="cuddAllDet.html#Cudd_addAgreement">Cudd_addAgreement</a>
<a href="cuddAllDet.html#Cudd_addOr">Cudd_addOr</a>
<a href="cuddAllDet.html#Cudd_addNand">Cudd_addNand</a>
<a href="cuddAllDet.html#Cudd_addNor">Cudd_addNor</a>
<a href="cuddAllDet.html#Cudd_addXor">Cudd_addXor</a>
<a href="cuddAllDet.html#Cudd_addXnor">Cudd_addXnor</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addBddInterval"><b>Cudd_addBddInterval</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE  <b>lower</b>, <i></i>
  CUDD_VALUE_TYPE  <b>upper</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all discriminants greater than or equal to lower and less than or equal to upper with 1, and all other discriminants with 0. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
<a href="cuddAllDet.html#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
<a href="cuddAllDet.html#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="cuddAllDet.html#Cudd_BddToAdd">Cudd_BddToAdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addBddIthBit"><b>Cudd_addBddIthBit</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>bit</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all discriminants whose i-th bit is equal to 1 with 1, and all other discriminants with 0. The i-th bit refers to the integer representation of the leaf value. If the value is has a fractional part, it is ignored. Repeated calls to this procedure allow one to transform an integer-valued ADD into an array of BDDs, one for each bit of the leaf values. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="cuddAllDet.html#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="cuddAllDet.html#Cudd_BddToAdd">Cudd_BddToAdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addBddPattern"><b>Cudd_addBddPattern</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all discriminants different from 0 with 1. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_BddToAdd">Cudd_BddToAdd</a>
<a href="cuddAllDet.html#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
<a href="cuddAllDet.html#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="cuddAllDet.html#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addBddStrictThreshold"><b>Cudd_addBddStrictThreshold</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE  <b>value</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all discriminants STRICTLY greater than value with 1, and all other discriminants with 0. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="cuddAllDet.html#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="cuddAllDet.html#Cudd_BddToAdd">Cudd_BddToAdd</a>
<a href="cuddAllDet.html#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addBddThreshold"><b>Cudd_addBddThreshold</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE  <b>value</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all discriminants greater than or equal to value with 1, and all other discriminants with 0. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="cuddAllDet.html#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="cuddAllDet.html#Cudd_BddToAdd">Cudd_BddToAdd</a>
<a href="cuddAllDet.html#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addCmpl"><b>Cudd_addCmpl</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Computes the complement of an ADD a la C language: The complement of 0 is 1 and the complement of everything else is 0. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addNegate">Cudd_addNegate</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addCompose"><b>Cudd_addCompose</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int  <b>v</b> <i></i>
)
</pre>
<dd> Substitutes g for x_v in the ADD for f. v is the index of the variable to be substituted. g must be a 0-1 ADD. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used. Returns the composed ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddCompose">Cudd_bddCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addComputeCube"><b>Cudd_addComputeCube</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>vars</b>, <i></i>
  int * <b>phase</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Computes the cube of an array of ADD variables. If non-null, the phase argument indicates which literal of each variable should appear in the cube. If phase[i] is nonzero, then the positive literal is used. If phase is NULL, the cube is positive unate. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddComputeCube">Cudd_bddComputeCube</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addConstrain"><b>Cudd_addConstrain</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Computes f constrain c (f @ c), for f an ADD and c a 0-1 ADD. List of special cases: <ul> <li> F @ 0 = 0 <li> F @ 1 = F <li> 0 @ c = 0 <li> 1 @ c = 1 <li> F @ F = 1 </ul> Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddConstrain">Cudd_bddConstrain</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addConst"><b>Cudd_addConst</b></a>(
  DdManager * <b>dd</b>, <i></i>
  CUDD_VALUE_TYPE  <b>c</b> <i></i>
)
</pre>
<dd> Retrieves the ADD for constant c if it already exists, or creates a new ADD. Returns a pointer to the ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="cuddAllDet.html#Cudd_addIthVar">Cudd_addIthVar</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addDiff"><b>Cudd_addDiff</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Returns NULL if not a terminal case; f op g otherwise, where f op g is plusinfinity if f=g; min(f,g) if f!=g.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addDivide"><b>Cudd_addDivide</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point division. Returns NULL if not a terminal case; f / g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addEvalConst"><b>Cudd_addEvalConst</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Checks whether ADD g is constant whenever ADD f is 1. f must be a 0-1 ADD. Returns a pointer to the resulting ADD (which may or may not be constant) or DD_NON_CONSTANT. If f is identically 0, the check is assumed to be successful, and the background value is returned. No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="cuddAllDet.html#Cudd_addLeq">Cudd_addLeq</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addExistAbstract"><b>Cudd_addExistAbstract</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Abstracts all the variables in cube from f by summing over all possible values taken by the variables. Returns the abstracted ADD.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addUnivAbstract">Cudd_addUnivAbstract</a>
<a href="cuddAllDet.html#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="cuddAllDet.html#Cudd_addOrAbstract">Cudd_addOrAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addFindMax"><b>Cudd_addFindMax</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns a pointer to a constant ADD.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addFindMin"><b>Cudd_addFindMin</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns a pointer to a constant ADD.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addGeneralVectorCompose"><b>Cudd_addGeneralVectorCompose</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vectorOn</b>, <i></i>
  DdNode ** <b>vectorOff</b> <i></i>
)
</pre>
<dd> Given a vector of ADDs, creates a new ADD by substituting the ADDs for the variables of the ADD f. vectorOn contains ADDs to be substituted for the x_v and vectorOff the ADDs to be substituted for x_v'. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addVectorCompose">Cudd_addVectorCompose</a>
<a href="cuddAllDet.html#Cudd_addNonSimCompose">Cudd_addNonSimCompose</a>
<a href="cuddAllDet.html#Cudd_addPermute">Cudd_addPermute</a>
<a href="cuddAllDet.html#Cudd_addCompose">Cudd_addCompose</a>
<a href="cuddAllDet.html#Cudd_bddVectorCompose">Cudd_bddVectorCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addHamming"><b>Cudd_addHamming</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>xVars</b>, <i></i>
  DdNode ** <b>yVars</b>, <i></i>
  int  <b>nVars</b> <i></i>
)
</pre>
<dd> Computes the Hamming distance ADD. Returns an ADD that gives the Hamming distance between its two arguments if successful; NULL otherwise. The two vectors xVars and yVars identify the variables that form the two arguments.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_addHarwell"><b>Cudd_addHarwell</b></a>(
  FILE * <b>fp</b>, <i>pointer to the input file</i>
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode ** <b>E</b>, <i>characteristic function of the graph</i>
  DdNode *** <b>x</b>, <i>array of row variables</i>
  DdNode *** <b>y</b>, <i>array of column variables</i>
  DdNode *** <b>xn</b>, <i>array of complemented row variables</i>
  DdNode *** <b>yn_</b>, <i>array of complemented column variables</i>
  int * <b>nx</b>, <i>number or row variables</i>
  int * <b>ny</b>, <i>number or column variables</i>
  int * <b>m</b>, <i>number of rows</i>
  int * <b>n</b>, <i>number of columns</i>
  int  <b>bx</b>, <i>first index of row variables</i>
  int  <b>sx</b>, <i>step of row variables</i>
  int  <b>by</b>, <i>first index of column variables</i>
  int  <b>sy</b>, <i>step of column variables</i>
  int  <b>pr</b> <i>verbosity level</i>
)
</pre>
<dd> Reads in a matrix in the format of the Harwell-Boeing benchmark suite. The variables are ordered as follows: <blockquote> x[0] y[0] x[1] y[1] ... </blockquote> 0 is the most significant bit. On input, nx and ny hold the numbers of row and column variables already in existence. On output, they hold the numbers of row and column variables actually used by the matrix. m and n are set to the numbers of rows and columns of the matrix. Their values on input are immaterial. Returns 1 on success; 0 otherwise. The ADD for the sparse matrix is returned in E, and its reference count is > 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addRead">Cudd_addRead</a>
<a href="cuddAllDet.html#Cudd_bddRead">Cudd_bddRead</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addIteConstant"><b>Cudd_addIteConstant</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITEconstant for ADDs. f must be a 0-1 ADD. Returns a pointer to the resulting ADD (which may or may not be constant) or DD_NON_CONSTANT. No new nodes are created. This function can be used, for instance, to check that g has a constant value (specified by h) whenever f is 1. If the constant value is unknown, then one should use Cudd_addEvalConst.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addIte">Cudd_addIte</a>
<a href="cuddAllDet.html#Cudd_addEvalConst">Cudd_addEvalConst</a>
<a href="cuddAllDet.html#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addIte"><b>Cudd_addIte</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITE(f,g,h). This procedure assumes that f is a 0-1 ADD. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addIthBit"><b>Cudd_addIthBit</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>bit</b> <i></i>
)
</pre>
<dd> Produces an ADD from another ADD by replacing all discriminants whose i-th bit is equal to 1 with 1, and all other discriminants with 0. The i-th bit refers to the integer representation of the leaf value. If the value is has a fractional part, it is ignored. Repeated calls to this procedure allow one to transform an integer-valued ADD into an array of ADDs, one for each bit of the leaf values. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addBddIthBit">Cudd_addBddIthBit</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addIthVar"><b>Cudd_addIthVar</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Retrieves the ADD variable with index i if it already exists, or creates a new ADD variable. Returns a pointer to the variable if successful; NULL otherwise. An ADD variable differs from a BDD variable because it points to the arithmetic zero, instead of having a complement pointer to 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="cuddAllDet.html#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="cuddAllDet.html#Cudd_addConst">Cudd_addConst</a>
<a href="cuddAllDet.html#Cudd_addNewVarAtLevel">Cudd_addNewVarAtLevel</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_addLeq"><b>Cudd_addLeq</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns 1 if f is less than or equal to g; 0 otherwise. No new nodes are created. This procedure works for arbitrary ADDs. For 0-1 ADDs Cudd_addEvalConst is more efficient.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="cuddAllDet.html#Cudd_addEvalConst">Cudd_addEvalConst</a>
<a href="cuddAllDet.html#Cudd_bddLeq">Cudd_bddLeq</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addLog"><b>Cudd_addLog</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Natural logarithm of an ADDs. Returns NULL if not a terminal case; log(f) otherwise. The discriminants of f must be positive double's.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addMonadicApply">Cudd_addMonadicApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addMatrixMultiply"><b>Cudd_addMatrixMultiply</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>A</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  DdNode ** <b>z</b>, <i></i>
  int  <b>nz</b> <i></i>
)
</pre>
<dd> Calculates the product of two matrices, A and B, represented as ADDs. This procedure implements the quasiring multiplication algorithm. A is assumed to depend on variables x (rows) and z (columns). B is assumed to depend on variables z (rows) and y (columns). The product of A and B then depends on x (rows) and y (columns). Only the z variables have to be explicitly identified; they are the "summation" variables. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addTimesPlus">Cudd_addTimesPlus</a>
<a href="cuddAllDet.html#Cudd_addTriangle">Cudd_addTriangle</a>
<a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addMaximum"><b>Cudd_addMaximum</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point max for Cudd_addApply. Returns NULL if not a terminal case; max(f,g) otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addMinimum"><b>Cudd_addMinimum</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point min for Cudd_addApply. Returns NULL if not a terminal case; min(f,g) otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addMinus"><b>Cudd_addMinus</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point subtraction. Returns NULL if not a terminal case; f - g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addMonadicApply"><b>Cudd_addMonadicApply</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DD_MAOP  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Applies op to the discriminants of f. Returns a pointer to the result if succssful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
<a href="cuddAllDet.html#Cudd_addLog">Cudd_addLog</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addNand"><b>Cudd_addNand</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> NAND of two 0-1 ADDs. Returns NULL if not a terminal case; f NAND g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addNegate"><b>Cudd_addNegate</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Computes the additive inverse of an ADD. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addCmpl">Cudd_addCmpl</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addNewVarAtLevel"><b>Cudd_addNewVarAtLevel</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Creates a new ADD variable. The new variable has an index equal to the largest previous index plus 1 and is positioned at the specified level in the order. Returns a pointer to the new variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="cuddAllDet.html#Cudd_addIthVar">Cudd_addIthVar</a>
<a href="cuddAllDet.html#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addNewVar"><b>Cudd_addNewVar</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Creates a new ADD variable. The new variable has an index equal to the largest previous index plus 1. Returns a pointer to the new variable if successful; NULL otherwise. An ADD variable differs from a BDD variable because it points to the arithmetic zero, instead of having a complement pointer to 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="cuddAllDet.html#Cudd_addIthVar">Cudd_addIthVar</a>
<a href="cuddAllDet.html#Cudd_addConst">Cudd_addConst</a>
<a href="cuddAllDet.html#Cudd_addNewVarAtLevel">Cudd_addNewVarAtLevel</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addNonSimCompose"><b>Cudd_addNonSimCompose</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b> <i></i>
)
</pre>
<dd> Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. This function implements non-simultaneous composition. If any of the functions being composed depends on any of the variables being substituted, then the result depends on the order of composition, which in turn depends on the variable order: The variables farther from the roots in the order are substituted first. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addVectorCompose">Cudd_addVectorCompose</a>
<a href="cuddAllDet.html#Cudd_addPermute">Cudd_addPermute</a>
<a href="cuddAllDet.html#Cudd_addCompose">Cudd_addCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addNor"><b>Cudd_addNor</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> NOR of two 0-1 ADDs. Returns NULL if not a terminal case; f NOR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addOneZeroMaximum"><b>Cudd_addOneZeroMaximum</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Returns 1 if f &gt; g and 0 otherwise. Used in conjunction with Cudd_addApply. Returns NULL if not a terminal case.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addOrAbstract"><b>Cudd_addOrAbstract</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Abstracts all the variables in cube from the 0-1 ADD f by taking the disjunction over all possible values taken by the variables. Returns the abstracted ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addUnivAbstract">Cudd_addUnivAbstract</a>
<a href="cuddAllDet.html#Cudd_addExistAbstract">Cudd_addExistAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addOr"><b>Cudd_addOr</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Disjunction of two 0-1 ADDs. Returns NULL if not a terminal case; f OR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addOuterSum"><b>Cudd_addOuterSum</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>M</b>, <i></i>
  DdNode * <b>r</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Takes the pointwise minimum of a matrix and the outer sum of two vectors. This procedure is used in the Floyd-Warshall all-pair shortest path algorithm. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addPermute"><b>Cudd_addPermute</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int * <b>permut</b> <i></i>
)
</pre>
<dd> Given a permutation in array permut, creates a new ADD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="cuddAllDet.html#Cudd_addSwapVariables">Cudd_addSwapVariables</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addPlus"><b>Cudd_addPlus</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point addition. Returns NULL if not a terminal case; f+g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_addRead"><b>Cudd_addRead</b></a>(
  FILE * <b>fp</b>, <i>input file pointer</i>
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode ** <b>E</b>, <i>characteristic function of the graph</i>
  DdNode *** <b>x</b>, <i>array of row variables</i>
  DdNode *** <b>y</b>, <i>array of column variables</i>
  DdNode *** <b>xn</b>, <i>array of complemented row variables</i>
  DdNode *** <b>yn_</b>, <i>array of complemented column variables</i>
  int * <b>nx</b>, <i>number or row variables</i>
  int * <b>ny</b>, <i>number or column variables</i>
  int * <b>m</b>, <i>number of rows</i>
  int * <b>n</b>, <i>number of columns</i>
  int  <b>bx</b>, <i>first index of row variables</i>
  int  <b>sx</b>, <i>step of row variables</i>
  int  <b>by</b>, <i>first index of column variables</i>
  int  <b>sy</b> <i>step of column variables</i>
)
</pre>
<dd> Reads in a sparse matrix specified in a simple format. The first line of the input contains the numbers of rows and columns. The remaining lines contain the elements of the matrix, one per line. Given a background value (specified by the background field of the manager), only the values different from it are explicitly listed. Each foreground element is described by two integers, i.e., the row and column number, and a real number, i.e., the value.<p> Cudd_addRead produces an ADD that depends on two sets of variables: x and y. The x variables (x[0] ... x[nx-1]) encode the row index and the y variables (y[0] ... y[ny-1]) encode the column index. x[0] and y[0] are the most significant bits in the indices. The variables may already exist or may be created by the function. The index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy.<p> On input, nx and ny hold the numbers of row and column variables already in existence. On output, they hold the numbers of row and column variables actually used by the matrix. When Cudd_addRead creates the variable arrays, the index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy. When some variables already exist Cudd_addRead expects the indices of the existing x variables to be bx+i*sx, and the indices of the existing y variables to be by+i*sy.<p> m and n are set to the numbers of rows and columns of the matrix. Their values on input are immaterial. The ADD for the sparse matrix is returned in E, and its reference count is > 0. Cudd_addRead returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> nx and ny are set to the numbers of row and column variables. m and n are set to the numbers of rows and columns. x and y are possibly extended to represent the array of row and column variables. Similarly for xn and yn_, which hold on return from Cudd_addRead the complements of the row and column variables.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addHarwell">Cudd_addHarwell</a>
<a href="cuddAllDet.html#Cudd_bddRead">Cudd_bddRead</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addResidue"><b>Cudd_addResidue</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of bits</i>
  int  <b>m</b>, <i>modulus</i>
  int  <b>options</b>, <i>options</i>
  int  <b>top</b> <i>index of top variable</i>
)
</pre>
<dd> Builds an ADD for the residue modulo m of an n-bit number. The modulus must be at least 2, and the number of bits at least 1. Parameter options specifies whether the MSB should be on top or the LSB; and whther the number whose residue is computed is in two's complement notation or not. The macro CUDD_RESIDUE_DEFAULT specifies LSB on top and unsigned number. The macro CUDD_RESIDUE_MSB specifies MSB on top, and the macro CUDD_RESIDUE_TC specifies two's complement residue. To request MSB on top and two's complement residue simultaneously, one can OR the two macros: CUDD_RESIDUE_MSB | CUDD_RESIDUE_TC. Cudd_addResidue returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addRestrict"><b>Cudd_addRestrict</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> ADD restrict according to Coudert and Madre's algorithm (ICCAD90). Returns the restricted ADD if successful; otherwise NULL. If application of restrict results in an ADD larger than the input ADD, the input ADD is returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addConstrain">Cudd_addConstrain</a>
<a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addRoundOff"><b>Cudd_addRoundOff</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>N</b> <i></i>
)
</pre>
<dd> Rounds off the discriminants of an ADD. The discriminants are rounded off to N digits after the decimal. Returns a pointer to the result ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addScalarInverse"><b>Cudd_addScalarInverse</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>epsilon</b> <i></i>
)
</pre>
<dd> Computes an n ADD where the discriminants are the multiplicative inverses of the corresponding discriminants of the argument ADD. Returns a pointer to the resulting ADD in case of success. Returns NULL if any discriminants smaller than epsilon is encountered.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addSetNZ"><b>Cudd_addSetNZ</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> This operator sets f to the value of g wherever g != 0. Returns NULL if not a terminal case; f op g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addSwapVariables"><b>Cudd_addSwapVariables</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Swaps two sets of variables of the same size (x and y) in the ADD f. The size is given by n. The two sets of variables are assumed to be disjoint. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addPermute">Cudd_addPermute</a>
<a href="cuddAllDet.html#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addThreshold"><b>Cudd_addThreshold</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Threshold operator for Apply (f if f &gt;=g; 0 if f&lt;g). Returns NULL if not a terminal case; f op g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addTimesPlus"><b>Cudd_addTimesPlus</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>A</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  DdNode ** <b>z</b>, <i></i>
  int  <b>nz</b> <i></i>
)
</pre>
<dd> Calculates the product of two matrices, A and B, represented as ADDs, using the CMU matrix by matrix multiplication procedure by Clarke et al.. Matrix A has x's as row variables and z's as column variables, while matrix B has z's as row variables and y's as column variables. Returns the pointer to the result if successful; NULL otherwise. The resulting matrix has x's as row variables and y's as column variables.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addMatrixMultiply">Cudd_addMatrixMultiply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addTimes"><b>Cudd_addTimes</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point multiplication. Returns NULL if not a terminal case; f * g otherwise. This function can be used also to take the AND of two 0-1 ADDs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addTriangle"><b>Cudd_addTriangle</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode ** <b>z</b>, <i></i>
  int  <b>nz</b> <i></i>
)
</pre>
<dd> Implements the semiring multiplication algorithm used in the triangulation step for the shortest path computation. f is assumed to depend on variables x (rows) and z (columns). g is assumed to depend on variables z (rows) and y (columns). The product of f and g then depends on x (rows) and y (columns). Only the z variables have to be explicitly identified; they are the "abstraction" variables. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addMatrixMultiply">Cudd_addMatrixMultiply</a>
<a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addUnivAbstract"><b>Cudd_addUnivAbstract</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Abstracts all the variables in cube from f by taking the product over all possible values taken by the variable. Returns the abstracted ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addExistAbstract">Cudd_addExistAbstract</a>
<a href="cuddAllDet.html#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
<a href="cuddAllDet.html#Cudd_addOrAbstract">Cudd_addOrAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addVectorCompose"><b>Cudd_addVectorCompose</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b> <i></i>
)
</pre>
<dd> Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addNonSimCompose">Cudd_addNonSimCompose</a>
<a href="cuddAllDet.html#Cudd_addPermute">Cudd_addPermute</a>
<a href="cuddAllDet.html#Cudd_addCompose">Cudd_addCompose</a>
<a href="cuddAllDet.html#Cudd_bddVectorCompose">Cudd_bddVectorCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addWalsh"><b>Cudd_addWalsh</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Generates a Walsh matrix in ADD form. Returns a pointer to the matrixi if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addXeqy"><b>Cudd_addXeqy</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates an ADD for the function x==y. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most significant bit. The ADD is built bottom-up. It has 3*N-1 internal nodes, if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Xeqy">Cudd_Xeqy</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addXnor"><b>Cudd_addXnor</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> XNOR of two 0-1 ADDs. Returns NULL if not a terminal case; f XNOR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_addXor"><b>Cudd_addXor</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> XOR of two 0-1 ADDs. Returns NULL if not a terminal case; f XOR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddAdjPermuteX"><b>Cudd_bddAdjPermuteX</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Rearranges a set of variables in the BDD B. The size of the set is given by n. This procedure is intended for the `randomization' of the priority functions. Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="cuddAllDet.html#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
<a href="cuddAllDet.html#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="cuddAllDet.html#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
<a href="cuddAllDet.html#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddAndAbstractLimit"><b>Cudd_bddAndAbstractLimit</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  unsigned int  <b>limit</b> <i></i>
)
</pre>
<dd> Takes the AND of two BDDs and simultaneously abstracts the variables in cube. The variables are existentially abstracted. Returns a pointer to the result is successful; NULL otherwise. In particular, if the number of new nodes created exceeds <code>limit</code>, this function returns NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddAndAbstract"><b>Cudd_bddAndAbstract</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the AND of two BDDs and simultaneously abstracts the variables in cube. The variables are existentially abstracted. Returns a pointer to the result is successful; NULL otherwise. Cudd_bddAndAbstract implements the semiring matrix multiplication algorithm for the boolean semiring.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addMatrixMultiply">Cudd_addMatrixMultiply</a>
<a href="cuddAllDet.html#Cudd_addTriangle">Cudd_addTriangle</a>
<a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddAndLimit"><b>Cudd_bddAndLimit</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  unsigned int  <b>limit</b> <i></i>
)
</pre>
<dd> Computes the conjunction of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than <code>limit</code> are required.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddAnd"><b>Cudd_bddAnd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the conjunction of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
<a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
<a href="cuddAllDet.html#Cudd_bddIntersect">Cudd_bddIntersect</a>
<a href="cuddAllDet.html#Cudd_bddOr">Cudd_bddOr</a>
<a href="cuddAllDet.html#Cudd_bddNand">Cudd_bddNand</a>
<a href="cuddAllDet.html#Cudd_bddNor">Cudd_bddNor</a>
<a href="cuddAllDet.html#Cudd_bddXor">Cudd_bddXor</a>
<a href="cuddAllDet.html#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddApproxConjDecomp"><b>Cudd_bddApproxConjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the first factor</i>
)
</pre>
<dd> Performs two-way conjunctive decomposition of a BDD. This procedure owes its name to the use of supersetting to obtain an initial factor of the given function. Returns the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise. The conjuncts produced by this procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
<a href="cuddAllDet.html#Cudd_RemapOverApprox">Cudd_RemapOverApprox</a>
<a href="cuddAllDet.html#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
<a href="cuddAllDet.html#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddApproxDisjDecomp"><b>Cudd_bddApproxDisjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD. Returns the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise. The disjuncts produced by this procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddBindVar"><b>Cudd_bddBindVar</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> This function sets a flag to prevent sifting of a variable. Returns 1 if successful; 0 otherwise (i.e., invalid variable index).
<p>

<dd> <b>Side Effects</b> Changes the "bindVar" flag in DdSubtable.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddUnbindVar">Cudd_bddUnbindVar</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddBooleanDiff"><b>Cudd_bddBooleanDiff</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Computes the boolean difference of f with respect to the variable with index x. Returns the BDD of the boolean difference if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode ** <i></i>
<a name="Cudd_bddCharToVect"><b>Cudd_bddCharToVect</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Computes a vector of BDDs whose image equals a non-zero function. The result depends on the variable order. The i-th component of the vector depends only on the first i variables in the order. Each BDD in the vector is not larger than the BDD of the given characteristic function. This function is based on the description of char-to-vect in "Verification of Sequential Machines Using Boolean Functional Vectors" by O. Coudert, C. Berthet and J. C. Madre. Returns a pointer to an array containing the result if successful; NULL otherwise. The size of the array equals the number of variables in the manager. The components of the solution have their reference counts already incremented (unlike the results of most other functions in the package.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddConstrain">Cudd_bddConstrain</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddClippingAndAbstract"><b>Cudd_bddClippingAndAbstract</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  DdNode * <b>cube</b>, <i>cube of variables to be abstracted</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g and simultaneously abstracts the variables in cube. The variables are existentially abstracted. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
<a href="cuddAllDet.html#Cudd_bddClippingAnd">Cudd_bddClippingAnd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddClippingAnd"><b>Cudd_bddClippingAnd</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddClosestCube"><b>Cudd_bddClosestCube</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int * <b>distance</b> <i></i>
)
</pre>
<dd> Finds a cube of f at minimum Hamming distance from the minterms of g. All the minterms of the cube are at the minimum distance. If the distance is 0, the cube belongs to the intersection of f and g. Returns the cube if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The distance is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_MinHammingDist">Cudd_MinHammingDist</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddCompose"><b>Cudd_bddCompose</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int  <b>v</b> <i></i>
)
</pre>
<dd> Substitutes g for x_v in the BDD for f. v is the index of the variable to be substituted. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used. Returns the composed BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addCompose">Cudd_addCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddComputeCube"><b>Cudd_bddComputeCube</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>vars</b>, <i></i>
  int * <b>phase</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Computes the cube of an array of BDD variables. If non-null, the phase argument indicates which literal of each variable should appear in the cube. If phase[i] is nonzero, then the positive literal is used. If phase is NULL, the cube is positive unate. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addComputeCube">Cudd_addComputeCube</a>
<a href="cuddAllDet.html#Cudd_IndicesToCube">Cudd_IndicesToCube</a>
<a href="cuddAllDet.html#Cudd_CubeArrayToBdd">Cudd_CubeArrayToBdd</a>
</code>

<dt><pre>
DdNode ** <i></i>
<a name="Cudd_bddConstrainDecomp"><b>Cudd_bddConstrainDecomp</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> BDD conjunctive decomposition as in McMillan's CAV96 paper. The decomposition is canonical only for a given variable order. If canonicity is required, variable ordering must be disabled after the decomposition has been computed. Returns an array with one entry for each BDD variable in the manager if successful; otherwise NULL. The components of the solution have their reference counts already incremented (unlike the results of most other functions in the package.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="cuddAllDet.html#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddConstrain"><b>Cudd_bddConstrain</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Computes f constrain c (f @ c). Uses a canonical form: (f' @ c) = ( f @ c)'. (Note: this is not true for c.) List of special cases: <ul> <li> f @ 0 = 0 <li> f @ 1 = f <li> 0 @ c = 0 <li> 1 @ c = 1 <li> f @ f = 1 <li> f @ f'= 0 </ul> Returns a pointer to the result if successful; NULL otherwise. Note that if F=(f1,...,fn) and reordering takes place while computing F @ c, then the image restriction property (Img(F,c) = Img(F @ c)) is lost.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
<a href="cuddAllDet.html#Cudd_addConstrain">Cudd_addConstrain</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_bddCorrelationWeights"><b>Cudd_bddCorrelationWeights</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  double * <b>prob</b> <i></i>
)
</pre>
<dd> Computes the correlation of f and g for given input probabilities. On input, prob[i] is supposed to contain the probability of the i-th input variable to be 1. If f == g, their correlation is 1. If f == g', their correlation is 0. Returns the probability that f and g have the same value. If it runs out of memory, returns (double)CUDD_OUT_OF_MEM. The correlation of f and the constant one gives the probability of f.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddCorrelation">Cudd_bddCorrelation</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_bddCorrelation"><b>Cudd_bddCorrelation</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the correlation of f and g. If f == g, their correlation is 1. If f == g', their correlation is 0. Returns the fraction of minterms in the ON-set of the EXNOR of f and g. If it runs out of memory, returns (double)CUDD_OUT_OF_MEM.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddCorrelationWeights">Cudd_bddCorrelationWeights</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddExistAbstract"><b>Cudd_bddExistAbstract</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Existentially abstracts all the variables in cube from f. Returns the abstracted BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
<a href="cuddAllDet.html#Cudd_addExistAbstract">Cudd_addExistAbstract</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddGenConjDecomp"><b>Cudd_bddGenConjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the array of conjuncts</i>
)
</pre>
<dd> Performs two-way conjunctive decomposition of a BDD. This procedure owes its name to the fact tht it generalizes the decomposition based on the cofactors with respect to one variable. Returns the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise. The conjuncts produced by this procedure tend to be balanced.
<p>

<dd> <b>Side Effects</b> The two factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddGenDisjDecomp"><b>Cudd_bddGenDisjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD. Returns the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise. The disjuncts produced by this procedure tend to be balanced.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddIntersect"><b>Cudd_bddIntersect</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first operand</i>
  DdNode * <b>g</b> <i>second operand</i>
)
</pre>
<dd> Computes a function included in the intersection of f and g. (That is, a witness that the intersection is not empty.) Cudd_bddIntersect tries to build as few new nodes as possible. If the only result of interest is whether f and g intersect, Cudd_bddLeq should be used instead.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="cuddAllDet.html#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIsNsVar"><b>Cudd_bddIsNsVar</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is next state. Returns 1 if the variable's type is present state; 0 if the variable exists but is not a present state; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetNsVar">Cudd_bddSetNsVar</a>
<a href="cuddAllDet.html#Cudd_bddIsPiVar">Cudd_bddIsPiVar</a>
<a href="cuddAllDet.html#Cudd_bddIsPsVar">Cudd_bddIsPsVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIsPiVar"><b>Cudd_bddIsPiVar</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Checks whether a variable is primary input. Returns 1 if the variable's type is primary input; 0 if the variable exists but is not a primary input; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetPiVar">Cudd_bddSetPiVar</a>
<a href="cuddAllDet.html#Cudd_bddIsPsVar">Cudd_bddIsPsVar</a>
<a href="cuddAllDet.html#Cudd_bddIsNsVar">Cudd_bddIsNsVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIsPsVar"><b>Cudd_bddIsPsVar</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is present state. Returns 1 if the variable's type is present state; 0 if the variable exists but is not a present state; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetPsVar">Cudd_bddSetPsVar</a>
<a href="cuddAllDet.html#Cudd_bddIsPiVar">Cudd_bddIsPiVar</a>
<a href="cuddAllDet.html#Cudd_bddIsNsVar">Cudd_bddIsNsVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIsVarEssential"><b>Cudd_bddIsVarEssential</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>id</b>, <i></i>
  int  <b>phase</b> <i></i>
)
</pre>
<dd> Determines whether a given variable is essential with a given phase in a BDD. Uses Cudd_bddIteConstant. Returns 1 if phase == 1 and f-->x_id, or if phase == 0 and f-->x_id'.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_FindEssential">Cudd_FindEssential</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIsVarHardGroup"><b>Cudd_bddIsVarHardGroup</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is set to be in a hard group. This function is used for lazy sifting. Returns 1 if the variable is marked to be in a hard group; 0 if the variable exists, but it is not marked to be in a hard group; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetVarHardGroup">Cudd_bddSetVarHardGroup</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIsVarToBeGrouped"><b>Cudd_bddIsVarToBeGrouped</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is set to be grouped. This function is used for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
int <i></i>
<a name="Cudd_bddIsVarToBeUngrouped"><b>Cudd_bddIsVarToBeUngrouped</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is set to be ungrouped. This function is used for lazy sifting. Returns 1 if the variable is marked to be ungrouped; 0 if the variable exists, but it is not marked to be ungrouped; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetVarToBeUngrouped">Cudd_bddSetVarToBeUngrouped</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_bddIsop"><b>Cudd_bddIsop</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b> <i></i>
)
</pre>
<dd> Computes a BDD in the interval between L and U with a simple sum-of-produuct cover. This procedure is similar to Cudd_zddIsop, but it does not return the ZDD for the cover. Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddIsop">Cudd_zddIsop</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddIteConstant"><b>Cudd_bddIteConstant</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITEconstant(f,g,h). Returns a pointer to the resulting BDD (which may or may not be constant) or DD_NON_CONSTANT. No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_bddIntersect">Cudd_bddIntersect</a>
<a href="cuddAllDet.html#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="cuddAllDet.html#Cudd_addIteConstant">Cudd_addIteConstant</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIterConjDecomp"><b>Cudd_bddIterConjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the array of conjuncts</i>
)
</pre>
<dd> Performs two-way conjunctive decomposition of a BDD. This procedure owes its name to the iterated use of supersetting to obtain a factor of the given function. Returns the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise. The conjuncts produced by this procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
<a href="cuddAllDet.html#Cudd_RemapOverApprox">Cudd_RemapOverApprox</a>
<a href="cuddAllDet.html#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
<a href="cuddAllDet.html#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddIterDisjDecomp"><b>Cudd_bddIterDisjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD. Returns the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise. The disjuncts produced by this procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddIte"><b>Cudd_bddIte</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITE(f,g,h). Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addIte">Cudd_addIte</a>
<a href="cuddAllDet.html#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
<a href="cuddAllDet.html#Cudd_bddIntersect">Cudd_bddIntersect</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddIthVar"><b>Cudd_bddIthVar</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Retrieves the BDD variable with index i if it already exists, or creates a new BDD variable. Returns a pointer to the variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="cuddAllDet.html#Cudd_addIthVar">Cudd_addIthVar</a>
<a href="cuddAllDet.html#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
<a href="cuddAllDet.html#Cudd_ReadVars">Cudd_ReadVars</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddLICompaction"><b>Cudd_bddLICompaction</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be minimized</i>
  DdNode * <b>c</b> <i>constraint (care set)</i>
)
</pre>
<dd> Performs safe minimization of a BDD. Given the BDD <code>f</code> of a function to be minimized and a BDD <code>c</code> representing the care set, Cudd_bddLICompaction produces the BDD of a function that agrees with <code>f</code> wherever <code>c</code> is 1. Safe minimization means that the size of the result is guaranteed not to exceed the size of <code>f</code>. This function is based on the DAC97 paper by Hong et al.. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddLeqUnless"><b>Cudd_bddLeqUnless</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>D</b> <i></i>
)
</pre>
<dd> Tells whether f is less than of equal to G unless D is 1. f, g, and D are BDDs. The function returns 1 if f is less than of equal to G, and 0 otherwise. No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_EquivDC">Cudd_EquivDC</a>
<a href="cuddAllDet.html#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="cuddAllDet.html#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddLeq"><b>Cudd_bddLeq</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns 1 if f is less than or equal to g; 0 otherwise. No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
<a href="cuddAllDet.html#Cudd_addEvalConst">Cudd_addEvalConst</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddLiteralSetIntersection"><b>Cudd_bddLiteralSetIntersection</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the intesection of two sets of literals represented as BDDs. Each set is represented as a cube of the literals in the set. The empty set is represented by the constant 1. No variable can be simultaneously present in both phases in a set. Returns a pointer to the BDD representing the intersected sets, if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddMakePrime"><b>Cudd_bddMakePrime</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>cube</b>, <i>cube to be expanded</i>
  DdNode * <b>f</b> <i>function of which the cube is to be made a prime</i>
)
</pre>
<dd> Expands cube to a prime implicant of f. Returns the prime if successful; NULL otherwise. In particular, NULL is returned if cube is not a real cube or is not an implicant of f.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddMinimize"><b>Cudd_bddMinimize</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Finds a small BDD that agrees with <code>f</code> over <code>c</code>. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
<a href="cuddAllDet.html#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
<a href="cuddAllDet.html#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddNPAnd"><b>Cudd_bddNPAnd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes f non-polluting-and g. The non-polluting AND of f and g is a hybrid of AND and Restrict. From Restrict, this operation takes the idea of existentially quantifying the top variable of the second operand if it does not appear in the first. Therefore, the variables that appear in the result also appear in f. For the rest, the function behaves like AND. Since the two operands play different roles, non-polluting AND is not commutative. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddNand"><b>Cudd_bddNand</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the NAND of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
<a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="cuddAllDet.html#Cudd_bddOr">Cudd_bddOr</a>
<a href="cuddAllDet.html#Cudd_bddNor">Cudd_bddNor</a>
<a href="cuddAllDet.html#Cudd_bddXor">Cudd_bddXor</a>
<a href="cuddAllDet.html#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddNewVarAtLevel"><b>Cudd_bddNewVarAtLevel</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Creates a new BDD variable. The new variable has an index equal to the largest previous index plus 1 and is positioned at the specified level in the order. Returns a pointer to the new variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="cuddAllDet.html#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="cuddAllDet.html#Cudd_addNewVarAtLevel">Cudd_addNewVarAtLevel</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddNewVar"><b>Cudd_bddNewVar</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Creates a new BDD variable. The new variable has an index equal to the largest previous index plus 1. Returns a pointer to the new variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="cuddAllDet.html#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="cuddAllDet.html#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddNor"><b>Cudd_bddNor</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the NOR of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
<a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="cuddAllDet.html#Cudd_bddOr">Cudd_bddOr</a>
<a href="cuddAllDet.html#Cudd_bddNand">Cudd_bddNand</a>
<a href="cuddAllDet.html#Cudd_bddXor">Cudd_bddXor</a>
<a href="cuddAllDet.html#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddOr"><b>Cudd_bddOr</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the disjunction of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
<a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="cuddAllDet.html#Cudd_bddNand">Cudd_bddNand</a>
<a href="cuddAllDet.html#Cudd_bddNor">Cudd_bddNor</a>
<a href="cuddAllDet.html#Cudd_bddXor">Cudd_bddXor</a>
<a href="cuddAllDet.html#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddPermute"><b>Cudd_bddPermute</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int * <b>permut</b> <i></i>
)
</pre>
<dd> Given a permutation in array permut, creates a new BDD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addPermute">Cudd_addPermute</a>
<a href="cuddAllDet.html#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
</code>

<dt><pre>
DdNode ** <i></i>
<a name="Cudd_bddPickArbitraryMinterms"><b>Cudd_bddPickArbitraryMinterms</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function from which to pick k minterms</i>
  DdNode ** <b>vars</b>, <i>array of variables</i>
  int  <b>n</b>, <i>size of <code>vars</code></i>
  int  <b>k</b> <i>number of minterms to find</i>
)
</pre>
<dd> Picks k on-set minterms evenly distributed from given DD. The minterms are in terms of <code>vars</code>. The array <code>vars</code> should contain at least all variables in the support of <code>f</code>; if this condition is not met the minterms built by this procedure may not be contained in <code>f</code>. Builds an array of BDDs for the minterms and returns a pointer to it if successful; NULL otherwise. There are three reasons why the procedure may fail: <ul> <li> It may run out of memory; <li> the function <code>f</code> may be the constant 0; <li> the minterms may not be contained in <code>f</code>. </ul>
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPickOneMinterm">Cudd_bddPickOneMinterm</a>
<a href="cuddAllDet.html#Cudd_bddPickOneCube">Cudd_bddPickOneCube</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddPickOneCube"><b>Cudd_bddPickOneCube</b></a>(
  DdManager * <b>ddm</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  char * <b>string</b> <i></i>
)
</pre>
<dd> Picks one on-set cube randomly from the given DD. The cube is written into an array of characters. The array must have at least as many entries as there are variables. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPickOneMinterm">Cudd_bddPickOneMinterm</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddPickOneMinterm"><b>Cudd_bddPickOneMinterm</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function from which to pick one minterm</i>
  DdNode ** <b>vars</b>, <i>array of variables</i>
  int  <b>n</b> <i>size of <code>vars</code></i>
)
</pre>
<dd> Picks one on-set minterm randomly from the given DD. The minterm is in terms of <code>vars</code>. The array <code>vars</code> should contain at least all variables in the support of <code>f</code>; if this condition is not met the minterm built by this procedure may not be contained in <code>f</code>. Builds a BDD for the minterm and returns a pointer to it if successful; NULL otherwise. There are three reasons why the procedure may fail: <ul> <li> It may run out of memory; <li> the function <code>f</code> may be the constant 0; <li> the minterm may not be contained in <code>f</code>. </ul>
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPickOneCube">Cudd_bddPickOneCube</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddPrintCover"><b>Cudd_bddPrintCover</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b> <i></i>
)
</pre>
<dd> Prints a sum of product cover for an incompletely specified function given by a lower bound and an upper bound. Each product is a prime implicant obtained by expanding the product corresponding to a path from node to the constant one. Uses the package default output file. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrintMinterm">Cudd_PrintMinterm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddReadPairIndex"><b>Cudd_bddReadPairIndex</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Reads a corresponding pair index for a given index. These pair indices are present and next state variable. Returns the corresponding variable index if the variable exists; -1 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetPairIndex">Cudd_bddSetPairIndex</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddRead"><b>Cudd_bddRead</b></a>(
  FILE * <b>fp</b>, <i>input file pointer</i>
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode ** <b>E</b>, <i>characteristic function of the graph</i>
  DdNode *** <b>x</b>, <i>array of row variables</i>
  DdNode *** <b>y</b>, <i>array of column variables</i>
  int * <b>nx</b>, <i>number or row variables</i>
  int * <b>ny</b>, <i>number or column variables</i>
  int * <b>m</b>, <i>number of rows</i>
  int * <b>n</b>, <i>number of columns</i>
  int  <b>bx</b>, <i>first index of row variables</i>
  int  <b>sx</b>, <i>step of row variables</i>
  int  <b>by</b>, <i>first index of column variables</i>
  int  <b>sy</b> <i>step of column variables</i>
)
</pre>
<dd> Reads in a graph (without labels) given as an adjacency matrix. The first line of the input contains the numbers of rows and columns of the adjacency matrix. The remaining lines contain the arcs of the graph, one per line. Each arc is described by two integers, i.e., the row and column number, or the indices of the two endpoints. Cudd_bddRead produces a BDD that depends on two sets of variables: x and y. The x variables (x[0] ... x[nx-1]) encode the row index and the y variables (y[0] ... y[ny-1]) encode the column index. x[0] and y[0] are the most significant bits in the indices. The variables may already exist or may be created by the function. The index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy.<p> On input, nx and ny hold the numbers of row and column variables already in existence. On output, they hold the numbers of row and column variables actually used by the matrix. When Cudd_bddRead creates the variable arrays, the index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy. When some variables already exist, Cudd_bddRead expects the indices of the existing x variables to be bx+i*sx, and the indices of the existing y variables to be by+i*sy.<p> m and n are set to the numbers of rows and columns of the matrix. Their values on input are immaterial. The BDD for the graph is returned in E, and its reference count is > 0. Cudd_bddRead returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> nx and ny are set to the numbers of row and column variables. m and n are set to the numbers of rows and columns. x and y are possibly extended to represent the array of row and column variables.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addHarwell">Cudd_addHarwell</a>
<a href="cuddAllDet.html#Cudd_addRead">Cudd_addRead</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_bddRealignDisable"><b>Cudd_bddRealignDisable</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables realignment of ZDD order to BDD order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
<a href="cuddAllDet.html#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_bddRealignEnable"><b>Cudd_bddRealignEnable</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Enables realignment of the BDD variable order to the ZDD variable order after the ZDDs have been reordered. The number of ZDD variables must be a multiple of the number of BDD variables for realignment to make sense. If this condition is not met, Cudd_zddReduceHeap will return 0. Let <code>M</code> be the ratio of the two numbers. For the purpose of realignment, the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> are reagarded as corresponding to BDD variable <code>i</code>. Realignment is initially disabled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddReduceHeap">Cudd_zddReduceHeap</a>
<a href="cuddAllDet.html#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
<a href="cuddAllDet.html#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
<a href="cuddAllDet.html#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
<a href="cuddAllDet.html#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddRealignmentEnabled"><b>Cudd_bddRealignmentEnabled</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Returns 1 if the realignment of BDD order to ZDD order is enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
<a href="cuddAllDet.html#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddResetVarToBeGrouped"><b>Cudd_bddResetVarToBeGrouped</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Resets a variable not to be grouped. This function is used for lazy sifting. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetVarToBeGrouped">Cudd_bddSetVarToBeGrouped</a>
<a href="cuddAllDet.html#Cudd_bddSetVarHardGroup">Cudd_bddSetVarHardGroup</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddRestrict"><b>Cudd_bddRestrict</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> BDD restrict according to Coudert and Madre's algorithm (ICCAD90). Returns the restricted BDD if successful; otherwise NULL. If application of restrict results in a BDD larger than the input BDD, the input BDD is returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="cuddAllDet.html#Cudd_addRestrict">Cudd_addRestrict</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddSetNsVar"><b>Cudd_bddSetNsVar</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Sets a variable type to next state. The variable type is used by lazy sifting. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetPiVar">Cudd_bddSetPiVar</a>
<a href="cuddAllDet.html#Cudd_bddSetPsVar">Cudd_bddSetPsVar</a>
<a href="cuddAllDet.html#Cudd_bddIsNsVar">Cudd_bddIsNsVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddSetPairIndex"><b>Cudd_bddSetPairIndex</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b>, <i>variable index</i>
  int  <b>pairIndex</b> <i>corresponding variable index</i>
)
</pre>
<dd> Sets a corresponding pair index for a given index. These pair indices are present and next state variable. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddReadPairIndex">Cudd_bddReadPairIndex</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddSetPiVar"><b>Cudd_bddSetPiVar</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Sets a variable type to primary input. The variable type is used by lazy sifting. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetPsVar">Cudd_bddSetPsVar</a>
<a href="cuddAllDet.html#Cudd_bddSetNsVar">Cudd_bddSetNsVar</a>
<a href="cuddAllDet.html#Cudd_bddIsPiVar">Cudd_bddIsPiVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddSetPsVar"><b>Cudd_bddSetPsVar</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Sets a variable type to present state. The variable type is used by lazy sifting. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetPiVar">Cudd_bddSetPiVar</a>
<a href="cuddAllDet.html#Cudd_bddSetNsVar">Cudd_bddSetNsVar</a>
<a href="cuddAllDet.html#Cudd_bddIsPsVar">Cudd_bddIsPsVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddSetVarHardGroup"><b>Cudd_bddSetVarHardGroup</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to be a hard group. This function is used for lazy sifting. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetVarToBeGrouped">Cudd_bddSetVarToBeGrouped</a>
<a href="cuddAllDet.html#Cudd_bddResetVarToBeGrouped">Cudd_bddResetVarToBeGrouped</a>
<a href="cuddAllDet.html#Cudd_bddIsVarHardGroup">Cudd_bddIsVarHardGroup</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddSetVarToBeGrouped"><b>Cudd_bddSetVarToBeGrouped</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to be grouped. This function is used for lazy sifting. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddSetVarHardGroup">Cudd_bddSetVarHardGroup</a>
<a href="cuddAllDet.html#Cudd_bddResetVarToBeGrouped">Cudd_bddResetVarToBeGrouped</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddSetVarToBeUngrouped"><b>Cudd_bddSetVarToBeUngrouped</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to be ungrouped. This function is used for lazy sifting. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIsVarToBeUngrouped">Cudd_bddIsVarToBeUngrouped</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddSqueeze"><b>Cudd_bddSqueeze</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>l</b>, <i>lower bound</i>
  DdNode * <b>u</b> <i>upper bound</i>
)
</pre>
<dd> Finds a small BDD in a function interval. Given BDDs <code>l</code> and <code>u</code>, representing the lower bound and upper bound of a function interval, Cudd_bddSqueeze produces the BDD of a function within the interval with a small BDD. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
<a href="cuddAllDet.html#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddSwapVariables"><b>Cudd_bddSwapVariables</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Swaps two sets of variables of the same size (x and y) in the BDD f. The size is given by n. The two sets of variables are assumed to be disjoint. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="cuddAllDet.html#Cudd_addSwapVariables">Cudd_addSwapVariables</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddTransfer"><b>Cudd_bddTransfer</b></a>(
  DdManager * <b>ddSource</b>, <i></i>
  DdManager * <b>ddDestination</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Convert a BDD from a manager to another one. The orders of the variables in the two managers may be different. Returns a pointer to the BDD in the destination manager if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_bddUnbindVar"><b>Cudd_bddUnbindVar</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> This function resets the flag that prevents the sifting of a variable. In successive variable reorderings, the variable will NOT be skipped, that is, sifted. Initially all variables can be sifted. It is necessary to call this function only to re-enable sifting after a call to Cudd_bddBindVar. Returns 1 if successful; 0 otherwise (i.e., invalid variable index).
<p>

<dd> <b>Side Effects</b> Changes the "bindVar" flag in DdSubtable.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddBindVar">Cudd_bddBindVar</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddUnivAbstract"><b>Cudd_bddUnivAbstract</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Universally abstracts all the variables in cube from f. Returns the abstracted BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="cuddAllDet.html#Cudd_addUnivAbstract">Cudd_addUnivAbstract</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddVarConjDecomp"><b>Cudd_bddVarConjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the array of conjuncts</i>
)
</pre>
<dd> Conjunctively decomposes one BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>(f+x)(f+x')</code>. The variable is chosen so as to balance the sizes of the two conjuncts and to keep them small. Returns the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The two factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddVarDisjDecomp"><b>Cudd_bddVarDisjDecomp</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>f*x + f*x'</code>. The variable is chosen so as to balance the sizes of the two disjuncts and to keep them small. Returns the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="cuddAllDet.html#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddVarIsBound"><b>Cudd_bddVarIsBound</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> This function returns 1 if a variable is enabled for sifting. Initially all variables can be sifted. This function returns 0 only if there has been a previous call to Cudd_bddBindVar for that variable not followed by a call to Cudd_bddUnbindVar. The function returns 0 also in the case in which the index of the variable is out of bounds.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddBindVar">Cudd_bddBindVar</a>
<a href="cuddAllDet.html#Cudd_bddUnbindVar">Cudd_bddUnbindVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_bddVarIsDependent"><b>Cudd_bddVarIsDependent</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>var</b> <i>variable</i>
)
</pre>
<dd> Checks whether a variable is dependent on others in a function. Returns 1 if the variable is dependent; 0 otherwise. No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddVarMap"><b>Cudd_bddVarMap</b></a>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdNode * <b>f</b> <i>function in which to remap variables</i>
)
</pre>
<dd> Remaps the variables of a BDD using the default variable map. A typical use of this function is to swap two sets of variables. The variable map must be registered with Cudd_SetVarMap. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="cuddAllDet.html#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
<a href="cuddAllDet.html#Cudd_SetVarMap">Cudd_SetVarMap</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddVectorCompose"><b>Cudd_bddVectorCompose</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b> <i></i>
)
</pre>
<dd> Given a vector of BDDs, creates a new BDD by substituting the BDDs for the variables of the BDD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="cuddAllDet.html#Cudd_bddCompose">Cudd_bddCompose</a>
<a href="cuddAllDet.html#Cudd_addVectorCompose">Cudd_addVectorCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddXnor"><b>Cudd_bddXnor</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the exclusive NOR of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
<a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="cuddAllDet.html#Cudd_bddOr">Cudd_bddOr</a>
<a href="cuddAllDet.html#Cudd_bddNand">Cudd_bddNand</a>
<a href="cuddAllDet.html#Cudd_bddNor">Cudd_bddNor</a>
<a href="cuddAllDet.html#Cudd_bddXor">Cudd_bddXor</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddXorExistAbstract"><b>Cudd_bddXorExistAbstract</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the exclusive OR of two BDDs and simultaneously abstracts the variables in cube. The variables are existentially abstracted. Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
<a href="cuddAllDet.html#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_bddXor"><b>Cudd_bddXor</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the exclusive OR of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIte">Cudd_bddIte</a>
<a href="cuddAllDet.html#Cudd_addApply">Cudd_addApply</a>
<a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="cuddAllDet.html#Cudd_bddOr">Cudd_bddOr</a>
<a href="cuddAllDet.html#Cudd_bddNand">Cudd_bddNand</a>
<a href="cuddAllDet.html#Cudd_bddNor">Cudd_bddNor</a>
<a href="cuddAllDet.html#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_tlcInfoFree"><b>Cudd_tlcInfoFree</b></a>(
  DdTlcInfo * <b>t</b> <i></i>
)
</pre>
<dd> Frees a DdTlcInfo Structure as well as the memory pointed by it.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddChange"><b>Cudd_zddChange</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Substitutes a variable with its complement in a ZDD. returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddComplement"><b>Cudd_zddComplement</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Computes a complement cover for a ZDD node. For lack of a better method, we first extract the function BDD from the ZDD cover, then make the complement of the ZDD cover from the complement of the BDD node by using ISOP. Returns a pointer to the resulting cover if successful; NULL otherwise. The result depends on current variable order.
<p>

<dd> <b>Side Effects</b> The result depends on current variable order.
<p>

<dt><pre>
double <i></i>
<a name="Cudd_zddCountDouble"><b>Cudd_zddCountDouble</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a ZDD. The result is returned as a double. If the procedure runs out of memory, it returns (double) CUDD_OUT_OF_MEM. This procedure is used in Cudd_zddCountMinterm.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddCountMinterm">Cudd_zddCountMinterm</a>
<a href="cuddAllDet.html#Cudd_zddCount">Cudd_zddCount</a>
</code>

<dt><pre>
double <i></i>
<a name="Cudd_zddCountMinterm"><b>Cudd_zddCountMinterm</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>path</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of the ZDD rooted at <code>node</code>. This procedure takes a parameter <code>path</code> that specifies how many variables are in the support of the function. If the procedure runs out of memory, it returns (double) CUDD_OUT_OF_MEM.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddCountDouble">Cudd_zddCountDouble</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddCount"><b>Cudd_zddCount</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b> <i></i>
)
</pre>
<dd> Returns an integer representing the number of minterms in a ZDD.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddCountDouble">Cudd_zddCountDouble</a>
</code>

<dt><pre>
char * <i></i>
<a name="Cudd_zddCoverPathToString"><b>Cudd_zddCoverPathToString</b></a>(
  DdManager * <b>zdd</b>, <i>DD manager</i>
  int * <b>path</b>, <i>path of ZDD representing a cover</i>
  char * <b>str</b> <i>pointer to string to use if != NULL</i>
)
</pre>
<dd> Converts a path of a ZDD representing a cover to a string. The string represents an implicant of the cover. The path is typically produced by Cudd_zddForeachPath. Returns a pointer to the string if successful; NULL otherwise. If the str input is NULL, it allocates a new string. The string passed to this function must have enough room for all variables and for the terminator.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddForeachPath">Cudd_zddForeachPath</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddDagSize"><b>Cudd_zddDagSize</b></a>(
  DdNode * <b>p_node</b> <i></i>
)
</pre>
<dd> Counts the number of nodes in a ZDD. This function duplicates Cudd_DagSize and is only retained for compatibility.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DagSize">Cudd_DagSize</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddDiffConst"><b>Cudd_zddDiffConst</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Inclusion test for ZDDs (P implies Q). No new nodes are generated by this procedure. Returns empty if true; a valid pointer different from empty or DD_NON_CONSTANT otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddDiff">Cudd_zddDiff</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddDiff"><b>Cudd_zddDiff</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Computes the difference of two ZDDs. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddDiffConst">Cudd_zddDiffConst</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddDivideF"><b>Cudd_zddDivideF</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Modified version of Cudd_zddDivide. This function may disappear in future releases.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddDivide"><b>Cudd_zddDivide</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the quotient of two unate covers represented by ZDDs. Unate covers use one ZDD variable for each BDD variable. Returns a pointer to the resulting ZDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddWeakDiv">Cudd_zddWeakDiv</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddDumpDot"><b>Cudd_zddDumpDot</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a file representing the argument ZDDs in a format suitable for the graph drawing program dot. It returns 1 in case of success; 0 otherwise (e.g., out-of-memory, file system full). Cudd_zddDumpDot does not close the file: This is the caller responsibility. Cudd_zddDumpDot uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames. Cudd_zddDumpDot uses the following convention to draw arcs: <ul> <li> solid line: THEN arcs; <li> dashed line: ELSE arcs. </ul> The dot options are chosen so that the drawing fits on a letter-size sheet.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="cuddAllDet.html#Cudd_zddPrintDebug">Cudd_zddPrintDebug</a>
</code>

<dt><pre>
DdGen * <i></i>
<a name="Cudd_zddFirstPath"><b>Cudd_zddFirstPath</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int ** <b>path</b> <i></i>
)
</pre>
<dd> Defines an iterator on the paths of a ZDD and finds its first path. Returns a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.<p> A path is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents an else arc out of a node, 1 represents a then arc out of a node, and 2 stands for the absence of a node. The size of the array equals the number of variables in the manager at the time Cudd_zddFirstCube is called.<p> The paths that end in the empty terminal are not enumerated.
<p>

<dd> <b>Side Effects</b> The first path is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddForeachPath">Cudd_zddForeachPath</a>
<a href="cuddAllDet.html#Cudd_zddNextPath">Cudd_zddNextPath</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<dt><pre>
 <i></i>
<a name="Cudd_zddForeachPath"><b>Cudd_zddForeachPath</b></a>(
   <b>manager</b>, <i></i>
   <b>f</b>, <i></i>
   <b>gen</b>, <i></i>
   <b>path</b> <i></i>
)
</pre>
<dd> Iterates over the paths of a ZDD f. <ul> <li> DdManager *manager; <li> DdNode *f; <li> DdGen *gen; <li> int *path; </ul> Cudd_zddForeachPath allocates and frees the generator. Therefore the application should not try to do that. Also, the path is freed at the end of Cudd_zddForeachPath and hence is not available outside of the loop.<p> CAUTION: It is assumed that dynamic reordering will not occur while there are open generators. It is the user's responsibility to make sure that dynamic reordering does not occur. As long as new nodes are not created during generation, and dynamic reordering is not called explicitly, dynamic reordering will not occur. Alternatively, it is sufficient to disable dynamic reordering. It is a mistake to dispose of a diagram on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddFirstPath">Cudd_zddFirstPath</a>
<a href="cuddAllDet.html#Cudd_zddNextPath">Cudd_zddNextPath</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="cuddAllDet.html#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddIntersect"><b>Cudd_zddIntersect</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Computes the intersection of two ZDDs. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddIsop"><b>Cudd_zddIsop</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b>, <i></i>
  DdNode ** <b>zdd_I</b> <i></i>
)
</pre>
<dd> Computes an irredundant sum of products (ISOP) in ZDD form from BDDs. The two BDDs L and U represent the lower bound and the upper bound, respectively, of the function. The ISOP uses two ZDD variables for each BDD variable: One for the positive literal, and one for the negative literal. These two variables should be adjacent in the ZDD order. The two ZDD variables corresponding to BDD variable <code>i</code> should have indices <code>2i</code> and <code>2i+1</code>. The result of this procedure depends on the variable order. If successful, Cudd_zddIsop returns the BDD for the function chosen from the interval. The ZDD representing the irredundant cover is returned as a side effect in zdd_I. In case of failure, NULL is returned.
<p>

<dd> <b>Side Effects</b> zdd_I holds the pointer to the ZDD for the ISOP on successful return.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIsop">Cudd_bddIsop</a>
<a href="cuddAllDet.html#Cudd_zddVarsFromBddVars">Cudd_zddVarsFromBddVars</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddIte"><b>Cudd_zddIte</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Computes the ITE of three ZDDs. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddIthVar"><b>Cudd_zddIthVar</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Retrieves the ZDD variable with index i if it already exists, or creates a new ZDD variable. Returns a pointer to the variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="cuddAllDet.html#Cudd_addIthVar">Cudd_addIthVar</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddNextPath"><b>Cudd_zddNextPath</b></a>(
  DdGen * <b>gen</b>, <i></i>
  int ** <b>path</b> <i></i>
)
</pre>
<dd> Generates the next path of a ZDD onset, using generator gen. Returns 0 if the enumeration is completed; 1 otherwise.
<p>

<dd> <b>Side Effects</b> The path is returned as a side effect. The generator is modified.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddForeachPath">Cudd_zddForeachPath</a>
<a href="cuddAllDet.html#Cudd_zddFirstPath">Cudd_zddFirstPath</a>
<a href="cuddAllDet.html#Cudd_GenFree">Cudd_GenFree</a>
<a href="cuddAllDet.html#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddPortFromBdd"><b>Cudd_zddPortFromBdd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b> <i></i>
)
</pre>
<dd> Converts a BDD into a ZDD. This function assumes that there is a one-to-one correspondence between the BDD variables and the ZDD variables, and that the variable order is the same for both types of variables. These conditions are established if the ZDD variables are created by one call to Cudd_zddVarsFromBddVars with multiplicity = 1. Returns a pointer to the resulting ZDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddVarsFromBddVars">Cudd_zddVarsFromBddVars</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddPortToBdd"><b>Cudd_zddPortToBdd</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Converts a ZDD into a BDD. Returns a pointer to the resulting ZDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddPortFromBdd">Cudd_zddPortFromBdd</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddPrintCover"><b>Cudd_zddPrintCover</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Prints a sum of products from a ZDD representing a cover. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddPrintMinterm">Cudd_zddPrintMinterm</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddPrintDebug"><b>Cudd_zddPrintDebug</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>n</b>, <i></i>
  int  <b>pr</b> <i></i>
)
</pre>
<dd> Prints to the standard output a DD and its statistics. The statistics include the number of nodes and the number of minterms. (The number of minterms is also the number of combinations in the set.) The statistics are printed if pr &gt; 0. Specifically: <ul> <li> pr = 0 : prints nothing <li> pr = 1 : prints counts of nodes and minterms <li> pr = 2 : prints counts + disjoint sum of products <li> pr = 3 : prints counts + list of nodes <li> pr &gt; 3 : prints counts + disjoint sum of products + list of nodes </ul> Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_zddPrintMinterm"><b>Cudd_zddPrintMinterm</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Prints a disjoint sum of product form for a ZDD. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddPrintDebug">Cudd_zddPrintDebug</a>
<a href="cuddAllDet.html#Cudd_zddPrintCover">Cudd_zddPrintCover</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_zddPrintSubtable"><b>Cudd_zddPrintSubtable</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prints the ZDD table for debugging purposes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddProduct"><b>Cudd_zddProduct</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the product of two covers represented by ZDDs. The result is also a ZDD. Returns a pointer to the result if successful; NULL otherwise. The covers on which Cudd_zddProduct operates use two ZDD variables for each function variable (one ZDD variable for each literal of the variable). Those two ZDD variables should be adjacent in the order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddUnateProduct">Cudd_zddUnateProduct</a>
</code>

<dt><pre>
long <i></i>
<a name="Cudd_zddReadNodeCount"><b>Cudd_zddReadNodeCount</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the number of nodes in ZDDs. This number always includes the two constants 1 and 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPeakNodeCount">Cudd_ReadPeakNodeCount</a>
<a href="cuddAllDet.html#Cudd_ReadNodeCount">Cudd_ReadNodeCount</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_zddRealignDisable"><b>Cudd_zddRealignDisable</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables realignment of ZDD order to BDD order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
<a href="cuddAllDet.html#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_zddRealignEnable"><b>Cudd_zddRealignEnable</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Enables realignment of the ZDD variable order to the BDD variable order after the BDDs and ADDs have been reordered. The number of ZDD variables must be a multiple of the number of BDD variables for realignment to make sense. If this condition is not met, Cudd_ReduceHeap will return 0. Let <code>M</code> be the ratio of the two numbers. For the purpose of realignment, the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> are reagarded as corresponding to BDD variable <code>i</code>. Realignment is initially disabled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
<a href="cuddAllDet.html#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
<a href="cuddAllDet.html#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
<a href="cuddAllDet.html#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
<a href="cuddAllDet.html#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddRealignmentEnabled"><b>Cudd_zddRealignmentEnabled</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Returns 1 if the realignment of ZDD order to BDD order is enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
<a href="cuddAllDet.html#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="cuddAllDet.html#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
</code>

<dt><pre>
int <i></i>
<a name="Cudd_zddReduceHeap"><b>Cudd_zddReduceHeap</b></a>(
  DdManager * <b>table</b>, <i>DD manager</i>
  Cudd_ReorderingType  <b>heuristic</b>, <i>method used for reordering</i>
  int  <b>minsize</b> <i>bound below which no reordering occurs</i>
)
</pre>
<dd> Main dynamic reordering routine for ZDDs. Calls one of the possible reordering procedures: <ul> <li>Swapping <li>Sifting <li>Symmetric Sifting </ul> For sifting and symmetric sifting it is possible to request reordering to convergence.<p> The core of all methods is the reordering procedure cuddZddSwapInPlace() which swaps two adjacent variables. Returns 1 in case of success; 0 otherwise. In the case of symmetric sifting (with and without convergence) returns 1 plus the number of symmetric variables, in case of success.
<p>

<dd> <b>Side Effects</b> Changes the variable order for all ZDDs and clears the cache.
<p>

<dt><pre>
int <i></i>
<a name="Cudd_zddShuffleHeap"><b>Cudd_zddShuffleHeap</b></a>(
  DdManager * <b>table</b>, <i>DD manager</i>
  int * <b>permutation</b> <i>required variable permutation</i>
)
</pre>
<dd> Reorders ZDD variables according to given permutation. The i-th entry of the permutation array contains the index of the variable that should be brought to the i-th level. The size of the array should be equal or greater to the number of variables currently in use. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the ZDD variable order for all diagrams and clears the cache.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddReduceHeap">Cudd_zddReduceHeap</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddSubset0"><b>Cudd_zddSubset0</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the negative cofactor of a ZDD w.r.t. a variable. In terms of combinations, the result is the set of all combinations in which the variable is negated. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddSubset1">Cudd_zddSubset1</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddSubset1"><b>Cudd_zddSubset1</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the positive cofactor of a ZDD w.r.t. a variable. In terms of combinations, the result is the set of all combinations in which the variable is asserted. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddSubset0">Cudd_zddSubset0</a>
</code>

<dt><pre>
void <i></i>
<a name="Cudd_zddSymmProfile"><b>Cudd_zddSymmProfile</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Prints statistics on symmetric ZDD variables.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddUnateProduct"><b>Cudd_zddUnateProduct</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the product of two unate covers represented as ZDDs. Unate covers use one ZDD variable for each BDD variable. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddProduct">Cudd_zddProduct</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="Cudd_zddUnion"><b>Cudd_zddUnion</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Computes the union of two ZDDs. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="Cudd_zddVarsFromBddVars"><b>Cudd_zddVarsFromBddVars</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>multiplicity</b> <i>how many ZDD variables are created for each BDD variable</i>
)
</pre>
<dd> Creates one or more ZDD variables for each BDD variable. If some ZDD variables already exist, only the missing variables are created. Parameter multiplicity allows the caller to control how many variables are created for each BDD variable in existence. For instance, if ZDDs are used to represent covers, two ZDD variables are required for each BDD variable. The order of the BDD variables is transferred to the ZDD variables. If a variable group tree exists for the BDD variables, a corresponding ZDD variable group tree is created by expanding the BDD variable tree. In any case, the ZDD variables derived from the same BDD variable are merged in a ZDD variable group. If a ZDD variable group tree exists, it is freed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="cuddAllDet.html#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="cuddAllDet.html#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddWeakDivF"><b>Cudd_zddWeakDivF</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Modified version of Cudd_zddWeakDiv. This function may disappear in future releases.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddWeakDiv">Cudd_zddWeakDiv</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="Cudd_zddWeakDiv"><b>Cudd_zddWeakDiv</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Applies weak division to two ZDDs representing two covers. Returns a pointer to the ZDD representing the result if successful; NULL otherwise. The result of weak division depends on the variable order. The covers on which Cudd_zddWeakDiv operates use two ZDD variables for each function variable (one ZDD variable for each literal of the variable). Those two ZDD variables should be adjacent in the order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddDivide">Cudd_zddDivide</a>
</code>

<dt><pre>
 <i></i>
<a name="DD_LSDIGIT"><b>DD_LSDIGIT</b></a>(
   <b>x</b> <i></i>
)
</pre>
<dd> Extract the least significant digit of a double digit. Used in the manipulation of arbitrary precision integers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>DD_MSDIGIT
</code>

<dt><pre>
 <i></i>
<a name="DD_MINUS_INFINITY"><b>DD_MINUS_INFINITY</b></a>(
   <b>dd</b> <i></i>
)
</pre>
<dd> Returns the minus infinity constant node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
DD_ZERO
DD_PLUS_INFINITY
</code>

<dt><pre>
 <i></i>
<a name="DD_MSDIGIT"><b>DD_MSDIGIT</b></a>(
   <b>x</b> <i></i>
)
</pre>
<dd> Extract the most significant digit of a double digit. Used in the manipulation of arbitrary precision integers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>DD_LSDIGIT
</code>

<dt><pre>
 <i></i>
<a name="DD_ONE"><b>DD_ONE</b></a>(
   <b>dd</b> <i></i>
)
</pre>
<dd> Returns the constant 1 node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ZERO
DD_PLUS_INFINITY
DD_MINUS_INFINITY
</code>

<dt><pre>
 <i></i>
<a name="DD_PLUS_INFINITY"><b>DD_PLUS_INFINITY</b></a>(
   <b>dd</b> <i></i>
)
</pre>
<dd> Returns the plus infinity constant node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
DD_ZERO
DD_MINUS_INFINITY
</code>

<dt><pre>
 <i></i>
<a name="DD_ZERO"><b>DD_ZERO</b></a>(
   <b>dd</b> <i></i>
)
</pre>
<dd> Returns the arithmetic 0 constant node. This is different from the logical zero. The latter is obtained by Cudd_Not(DD_ONE(dd)).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
<a href="cuddAllDet.html#Cudd_Not">Cudd_Not</a>
DD_PLUS_INFINITY
DD_MINUS_INFINITY
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddApplyRecur"><b>cuddAddApplyRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DD_AOP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addApply. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddAddMonadicApplyRecur">cuddAddMonadicApplyRecur</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddBddDoPattern"><b>cuddAddBddDoPattern</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddPattern. Returns a pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddCmplRecur"><b>cuddAddCmplRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addCmpl. Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addCmpl">Cudd_addCmpl</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddComposeRecur"><b>cuddAddComposeRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>proj</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addCompose. Returns the composed BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addCompose">Cudd_addCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddConstrainRecur"><b>cuddAddConstrainRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addConstrain. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addConstrain">Cudd_addConstrain</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddExistAbstractRecur"><b>cuddAddExistAbstractRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addExistAbstract. Returns the ADD obtained by abstracting the variables of cube from f, if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddIteRecur"><b>cuddAddIteRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addIte(f,g,h). Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addIte">Cudd_addIte</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddMonadicApplyRecur"><b>cuddAddMonadicApplyRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DD_MAOP  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addMonadicApply. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddAddApplyRecur">cuddAddApplyRecur</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddNegateRecur"><b>cuddAddNegateRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addNegate. Returns a pointer to the result.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddOrAbstractRecur"><b>cuddAddOrAbstractRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addOrAbstract. Returns the ADD obtained by abstracting the variables of cube from f, if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddRestrictRecur"><b>cuddAddRestrictRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addRestrict. Returns the restricted ADD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_addRestrict">Cudd_addRestrict</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddRoundOffRecur"><b>cuddAddRoundOffRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  double  <b>trunc</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addRoundOff. Returns a pointer to the result.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddScalarInverseRecur"><b>cuddAddScalarInverseRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>epsilon</b> <i></i>
)
</pre>
<dd> Returns a pointer to the resulting ADD in case of success. Returns NULL if any discriminants smaller than epsilon is encountered.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddAddUnivAbstractRecur"><b>cuddAddUnivAbstractRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addUnivAbstract. Returns the ADD obtained by abstracting the variables of cube from f, if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
 <i></i>
<a name="cuddAdjust"><b>cuddAdjust</b></a>(
   <b>x</b> <i></i>
)
</pre>
<dd> Enforces DD_MINUS_INF_VAL <= x <= DD_PLUS_INF_VAL. Furthermore, if x <= DD_MINUS_INF_VAL/2, x is set to DD_MINUS_INF_VAL. Similarly, if DD_PLUS_INF_VAL/2 <= x, x is set to DD_PLUS_INF_VAL. Normally this macro is a NOOP. However, if HAVE_IEEE_754 is not defined, it makes sure that a value does not get larger than infinity in absolute value, and once it gets to infinity, stays there. If the value overflows before this macro is applied, no recovery is possible.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddAllocNode"><b>cuddAllocNode</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Fast storage allocation for DdNodes in the table. The first 4 bytes of a chunk contain a pointer to the next block; the rest contains DD_MEM_CHUNK spaces for DdNodes. Returns a pointer to a new node if successful; NULL is memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddAnnealing"><b>cuddAnnealing</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Get x, y by random selection. Choose either exchange or jump randomly. In case of jump, choose between jump_up and jump_down randomly. Do exchange or jump and get optimal case. Loop until there is no improvement or temperature reaches minimum. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddBddAlignToZdd"><b>cuddBddAlignToZdd</b></a>(
  DdManager * <b>table</b> <i>DD manager</i>
)
</pre>
<dd> Reorders BDD variables according to the order of the ZDD variables. This function can be called at the end of ZDD reordering to insure that the order of the BDD variables is consistent with the order of the ZDD variables. The number of ZDD variables must be a multiple of the number of BDD variables. Let <code>M</code> be the ratio of the two numbers. cuddBddAlignToZdd then considers the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> as corresponding to BDD variable <code>i</code>. This function should be normally called from Cudd_zddReduceHeap, which clears the cache. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable order for all diagrams and performs garbage collection of the BDD unique table.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ShuffleHeap">Cudd_ShuffleHeap</a>
<a href="cuddAllDet.html#Cudd_zddReduceHeap">Cudd_zddReduceHeap</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddAndAbstractRecur"><b>cuddBddAndAbstractRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the AND of two BDDs and simultaneously abstracts the variables in cube. The variables are existentially abstracted. Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddAndRecur"><b>cuddBddAndRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddAnd by taking the conjunction of two BDDs. Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddBooleanDiffRecur"><b>cuddBddBooleanDiffRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>var</b> <i></i>
)
</pre>
<dd> Performs the recursive steps of Cudd_bddBoleanDiff. Returns the BDD obtained by XORing the cofactors of f with respect to var if successful; NULL otherwise. Exploits the fact that dF/dx = dF'/dx.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddClippingAndAbstract"><b>cuddBddClippingAndAbstract</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  DdNode * <b>cube</b>, <i>cube of variables to be abstracted</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g and simultaneously abstracts the variables in cube. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddClippingAndAbstract">Cudd_bddClippingAndAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddClippingAnd"><b>cuddBddClippingAnd</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g. Returns a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddClippingAnd">Cudd_bddClippingAnd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddClosestCube"><b>cuddBddClosestCube</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  CUDD_VALUE_TYPE  <b>bound</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddClosestCube. Returns the cube if succesful; NULL otherwise. The procedure uses a four-way recursion to examine all four combinations of cofactors of <code>f</code> and <code>g</code> according to the following formula. <pre> H(f,g) = min(H(ft,gt), H(fe,ge), H(ft,ge)+1, H(fe,gt)+1) </pre> Bounding is based on the following observations. <ul> <li> If we already found two points at distance 0, there is no point in continuing. Furthermore, <li> If F == not(G) then the best we can hope for is a minimum distance of 1. If we have already found two points at distance 1, there is no point in continuing. (Indeed, H(F,G) == 1 in this case. We have to continue, though, to find the cube.) </ul> The variable <code>bound</code> is set at the largest value of the distance that we are still interested in. Therefore, we desist when <pre> (bound == -1) and (F != not(G)) or (bound == 0) and (F == not(G)). </pre> If we were maximally aggressive in using the bound, we would always set the bound to the minimum distance seen thus far minus one. That is, we would maintain the invariant <pre> bound < minD, </pre> except at the very beginning, when we have no value for <code>minD</code>.<p> However, we do not use <code>bound < minD</code> when examining the two negative cofactors, because we try to find a large cube at minimum distance. To do so, we try to find a cube in the negative cofactors at the same or smaller distance from the cube found in the positive cofactors.<p> When we compute <code>H(ft,ge)</code> and <code>H(fe,gt)</code> we know that we are going to add 1 to the result of the recursive call to account for the difference in the splitting variable. Therefore, we decrease the bound correspondingly.<p> Another important observation concerns the need of examining all four pairs of cofators only when both <code>f</code> and <code>g</code> depend on the top variable.<p> Suppose <code>gt == ge == g</code>. (That is, <code>g</code> does not depend on the top variable.) Then <pre> H(f,g) = min(H(ft,g), H(fe,g), H(ft,g)+1, H(fe,g)+1) = min(H(ft,g), H(fe,g)) . </pre> Therefore, under these circumstances, we skip the two "cross" cases.<p> An interesting feature of this function is the scheme used for caching the results in the global computed table. Since we have a cube and a distance, we combine them to form an ADD. The combination replaces the zero child of the top node of the cube with the negative of the distance. (The use of the negative is to avoid ambiguity with 1.) The degenerate cases (zero and one) are treated specially because the distance is known (0 for one, and infinity for zero).
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddClosestCube">Cudd_bddClosestCube</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddComposeRecur"><b>cuddBddComposeRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>proj</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCompose. Exploits the fact that the composition of f' with g produces the complement of the composition of f with g to better utilize the cache. Returns the composed BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddCompose">Cudd_bddCompose</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddConstrainRecur"><b>cuddBddConstrainRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddConstrain. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddConstrain">Cudd_bddConstrain</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddExistAbstractRecur"><b>cuddBddExistAbstractRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive steps of Cudd_bddExistAbstract. Returns the BDD obtained by abstracting the variables of cube from f if successful; NULL otherwise. It is also used by Cudd_bddUnivAbstract.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="cuddAllDet.html#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddIntersectRecur"><b>cuddBddIntersectRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddIntersect.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIntersect">Cudd_bddIntersect</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="cuddBddIsop"><b>cuddBddIsop</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddIsop.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddIsop">Cudd_bddIsop</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddIteRecur"><b>cuddBddIteRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddIte. Returns a pointer to the resulting BDD. NULL if the intermediate result blows up or if reordering occurs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddLICompaction"><b>cuddBddLICompaction</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be minimized</i>
  DdNode * <b>c</b> <i>constraint (care set)</i>
)
</pre>
<dd> Performs safe minimization of a BDD. Given the BDD <code>f</code> of a function to be minimized and a BDD <code>c</code> representing the care set, Cudd_bddLICompaction produces the BDD of a function that agrees with <code>f</code> wherever <code>c</code> is 1. Safe minimization means that the size of the result is guaranteed not to exceed the size of <code>f</code>. This function is based on the DAC97 paper by Hong et al.. Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddLiteralSetIntersectionRecur"><b>cuddBddLiteralSetIntersectionRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddLiteralSetIntersection. Scans the cubes for common variables, and checks whether they agree in phase. Returns a pointer to the resulting cube if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddMakePrime"><b>cuddBddMakePrime</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>cube</b>, <i>cube to be expanded</i>
  DdNode * <b>f</b> <i>function of which the cube is to be made a prime</i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddMakePrime. Returns the prime if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddNPAndRecur"><b>cuddBddNPAndRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddNPAnd. Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddNPAnd">Cudd_bddNPAnd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddRestrictRecur"><b>cuddBddRestrictRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddRestrict. Returns the restricted BDD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddTransfer"><b>cuddBddTransfer</b></a>(
  DdManager * <b>ddS</b>, <i></i>
  DdManager * <b>ddD</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Convert a BDD from a manager to another one. Returns a pointer to the BDD in the destination manager if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddTransfer">Cudd_bddTransfer</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddXorExistAbstractRecur"><b>cuddBddXorExistAbstractRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the exclusive OR of two BDDs and simultaneously abstracts the variables in cube. The variables are existentially abstracted. Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBddXorRecur"><b>cuddBddXorRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddXor by taking the exclusive OR of two BDDs. Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_bddXor">Cudd_bddXor</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddBiasedUnderApprox"><b>cuddBiasedUnderApprox</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  DdNode * <b>b</b>, <i>bias function</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=1</i>
)
</pre>
<dd> Applies the biased remapping underappoximation algorithm. Proceeds in three phases: <ul> <li> collect information on each node in the BDD; this is done via DFS. <li> traverse the BDD in top-down fashion and compute for each node whether remapping increases density. <li> traverse the BDD via DFS and actually perform the elimination. </ul> Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_BiasedUnderApprox">Cudd_BiasedUnderApprox</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCProjectionRecur"><b>cuddCProjectionRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>R</b>, <i></i>
  DdNode * <b>Y</b>, <i></i>
  DdNode * <b>Ysupp</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CProjection. Returns the projection if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_CProjection">Cudd_CProjection</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddCacheFlush"><b>cuddCacheFlush</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Flushes the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddCacheInsert1"><b>cuddCacheInsert1</b></a>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache for a function with two operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheInsert">cuddCacheInsert</a>
<a href="cuddAllDet.html#cuddCacheInsert2">cuddCacheInsert2</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddCacheInsert2"><b>cuddCacheInsert2</b></a>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache for a function with two operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheInsert">cuddCacheInsert</a>
<a href="cuddAllDet.html#cuddCacheInsert1">cuddCacheInsert1</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddCacheInsert"><b>cuddCacheInsert</b></a>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheInsert2">cuddCacheInsert2</a>
<a href="cuddAllDet.html#cuddCacheInsert1">cuddCacheInsert1</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCacheLookup1Zdd"><b>cuddCacheLookup1Zdd</b></a>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheLookupZdd">cuddCacheLookupZdd</a>
<a href="cuddAllDet.html#cuddCacheLookup2Zdd">cuddCacheLookup2Zdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCacheLookup1"><b>cuddCacheLookup1</b></a>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheLookup">cuddCacheLookup</a>
<a href="cuddAllDet.html#cuddCacheLookup2">cuddCacheLookup2</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCacheLookup2Zdd"><b>cuddCacheLookup2Zdd</b></a>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheLookupZdd">cuddCacheLookupZdd</a>
<a href="cuddAllDet.html#cuddCacheLookup1Zdd">cuddCacheLookup1Zdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCacheLookup2"><b>cuddCacheLookup2</b></a>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheLookup">cuddCacheLookup</a>
<a href="cuddAllDet.html#cuddCacheLookup1">cuddCacheLookup1</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCacheLookupZdd"><b>cuddCacheLookupZdd</b></a>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheLookup2Zdd">cuddCacheLookup2Zdd</a>
<a href="cuddAllDet.html#cuddCacheLookup1Zdd">cuddCacheLookup1Zdd</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCacheLookup"><b>cuddCacheLookup</b></a>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheLookup2">cuddCacheLookup2</a>
<a href="cuddAllDet.html#cuddCacheLookup1">cuddCacheLookup1</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddCacheProfile"><b>cuddCacheProfile</b></a>(
  DdManager * <b>table</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Computes and prints a profile of the cache usage. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddCacheResize"><b>cuddCacheResize</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Resizes the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddCheckCube"><b>cuddCheckCube</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Checks whether g is the BDD of a cube. Returns 1 in case of success; 0 otherwise. The constant 1 is a valid cube, but all other constant functions cause cuddCheckCube to return 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
 <i></i>
<a name="cuddClean"><b>cuddClean</b></a>(
   <b>p</b> <i></i>
)
</pre>
<dd> Clears the 4 least significant bits of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
void <i></i>
<a name="cuddClearDeathRow"><b>cuddClearDeathRow</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Clears the death row.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="cuddAllDet.html#Cudd_IterDerefBdd">Cudd_IterDerefBdd</a>
<a href="cuddAllDet.html#Cudd_CheckZeroRef">Cudd_CheckZeroRef</a>
<a href="cuddAllDet.html#cuddGarbageCollect">cuddGarbageCollect</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddCofactorRecur"><b>cuddCofactorRecur</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_Cofactor. Returns a pointer to the cofactor if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Cofactor">Cudd_Cofactor</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddCollectNodes"><b>cuddCollectNodes</b></a>(
  DdNode * <b>f</b>, <i></i>
  st_table * <b>visited</b> <i></i>
)
</pre>
<dd> Traverses the DD f and collects all its nodes in a symbol table. f is assumed to be a regular pointer and cuddCollectNodes guarantees this assumption in the recursive calls. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddComputeFloorLog2"><b>cuddComputeFloorLog2</b></a>(
  unsigned int  <b>value</b> <i></i>
)
</pre>
<dd> Returns the floor of the logarithm to the base 2. The input value is assumed to be greater than 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddConstantLookup"><b>cuddConstantLookup</b></a>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Looks up in the cache for the result of op applied to f, g, and h. Assumes that the calling procedure (e.g., Cudd_bddIteConstant) is only interested in whether the result is constant or not. Returns the result if found (possibly DD_NON_CONSTANT); otherwise it returns NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddCacheLookup">cuddCacheLookup</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddDeallocMove"><b>cuddDeallocMove</b></a>(
   <b>unique</b>, <i></i>
   <b>node</b> <i></i>
)
</pre>
<dd> Adds node to the head of the free list. Does not deallocate memory chunks that become free. This function is also used by the dynamic reordering functions.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddDeallocNode">cuddDeallocNode</a>
<a href="cuddAllDet.html#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddDeallocNode"><b>cuddDeallocNode</b></a>(
   <b>unique</b>, <i></i>
   <b>node</b> <i></i>
)
</pre>
<dd> Adds node to the head of the free list. Does not deallocate memory chunks that become free. This function is also used by the dynamic reordering functions.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddAllocNode">cuddAllocNode</a>
<a href="cuddAllDet.html#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
<a href="cuddAllDet.html#cuddDeallocMove">cuddDeallocMove</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddDeref"><b>cuddDeref</b></a>(
   <b>n</b> <i></i>
)
</pre>
<dd> Decreases the reference count of node. It is primarily used in recursive procedures to decrease the ref count of a result node before returning it. This accomplishes the goal of removing the protection applied by a previous cuddRef. This being a macro, it is faster than Cudd_Deref, but it cannot be used in constructs like cuddDeref(a = b()).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Deref">Cudd_Deref</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddDestroySubtables"><b>cuddDestroySubtables</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Destroys the n most recently created subtables in a unique table. n should be positive. The subtables should not contain any live nodes, except the (isolated) projection function. The projection functions are freed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The variable map used for fast variable substitution is destroyed if it exists. In this case the cache is also cleared.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddInsertSubtables">cuddInsertSubtables</a>
<a href="cuddAllDet.html#Cudd_SetVarMap">Cudd_SetVarMap</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddDynamicAllocNode"><b>cuddDynamicAllocNode</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Dynamically allocates a Node. This procedure is similar to cuddAllocNode in Cudd_Table.c, but it does not attempt garbage collection, because during reordering there are no dead nodes. Returns a pointer to a new node if successful; NULL is memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddAllocNode">cuddAllocNode</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddExact"><b>cuddExact</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Exact variable ordering algorithm. Finds an optimum order for the variables between lower and upper. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
 <i></i>
<a name="cuddE"><b>cuddE</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the else child of an internal node. If <code>node</code> is a constant node, the result is unpredictable. The pointer passed to cuddE must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_E">Cudd_E</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddFreeTable"><b>cuddFreeTable</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Frees the resources associated to a unique table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddInitTable">cuddInitTable</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddGarbageCollect"><b>cuddGarbageCollect</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>clearCache</b> <i></i>
)
</pre>
<dd> Performs garbage collection on the BDD and ZDD unique tables. If clearCache is 0, the cache is not cleared. This should only be specified if the cache has been cleared right before calling cuddGarbageCollect. (As in the case of dynamic reordering.) Returns the total number of deleted nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddGa"><b>cuddGa</b></a>(
  DdManager * <b>table</b>, <i>manager</i>
  int  <b>lower</b>, <i>lowest level to be reordered</i>
  int  <b>upper</b> <i>highest level to be reorderded</i>
)
</pre>
<dd> Genetic algorithm for DD reordering. The two children of a crossover will be stored in storedd[popsize
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddGetBranches"><b>cuddGetBranches</b></a>(
  DdNode * <b>g</b>, <i></i>
  DdNode ** <b>g1</b>, <i></i>
  DdNode ** <b>g0</b> <i></i>
)
</pre>
<dd> Computes the children of g.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdHashTable * <i></i>
<a name="cuddHashTableInit"><b>cuddHashTableInit</b></a>(
  DdManager * <b>manager</b>, <i></i>
  unsigned int  <b>keySize</b>, <i></i>
  unsigned int  <b>initSize</b> <i></i>
)
</pre>
<dd> Initializes a hash table. Returns a pointer to the new table if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableQuit">cuddHashTableQuit</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddHashTableInsert1"><b>cuddHashTableInsert1</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is one pointer. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="cuddAllDet.html#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="cuddAllDet.html#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="cuddAllDet.html#cuddHashTableLookup1">cuddHashTableLookup1</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddHashTableInsert2"><b>cuddHashTableInsert2</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is composed of two pointers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="cuddAllDet.html#cuddHashTableInsert1">cuddHashTableInsert1</a>
<a href="cuddAllDet.html#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="cuddAllDet.html#cuddHashTableLookup2">cuddHashTableLookup2</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddHashTableInsert3"><b>cuddHashTableInsert3</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is composed of three pointers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="cuddAllDet.html#cuddHashTableInsert1">cuddHashTableInsert1</a>
<a href="cuddAllDet.html#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="cuddAllDet.html#cuddHashTableLookup3">cuddHashTableLookup3</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddHashTableInsert"><b>cuddHashTableInsert</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNodePtr * <b>key</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key has more than three pointers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>[cuddHashTableInsert1
<a href="cuddAllDet.html#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="cuddAllDet.html#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="cuddAllDet.html#cuddHashTableLookup">cuddHashTableLookup</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddHashTableLookup1"><b>cuddHashTableLookup1</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of one pointer in a hash table. Returns the value associated to the key if there is an entry for the given key in the table; NULL otherwise. If the entry is present, its reference counter is decremented if not saturated. If the counter reaches 0, the value of the entry is dereferenced, and the entry is returned to the free list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="cuddAllDet.html#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="cuddAllDet.html#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="cuddAllDet.html#cuddHashTableInsert1">cuddHashTableInsert1</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddHashTableLookup2"><b>cuddHashTableLookup2</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of two pointer in a hash table. Returns the value associated to the key if there is an entry for the given key in the table; NULL otherwise. If the entry is present, its reference counter is decremented if not saturated. If the counter reaches 0, the value of the entry is dereferenced, and the entry is returned to the free list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="cuddAllDet.html#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="cuddAllDet.html#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="cuddAllDet.html#cuddHashTableInsert2">cuddHashTableInsert2</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddHashTableLookup3"><b>cuddHashTableLookup3</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of three pointers in a hash table. Returns the value associated to the key if there is an entry for the given key in the table; NULL otherwise. If the entry is present, its reference counter is decremented if not saturated. If the counter reaches 0, the value of the entry is dereferenced, and the entry is returned to the free list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="cuddAllDet.html#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="cuddAllDet.html#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="cuddAllDet.html#cuddHashTableInsert3">cuddHashTableInsert3</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddHashTableLookup"><b>cuddHashTableLookup</b></a>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNodePtr * <b>key</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of more than three pointers in a hash table. Returns the value associated to the key if there is an entry for the given key in the table; NULL otherwise. If the entry is present, its reference counter is decremented if not saturated. If the counter reaches 0, the value of the entry is dereferenced, and the entry is returned to the free list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="cuddAllDet.html#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="cuddAllDet.html#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="cuddAllDet.html#cuddHashTableInsert">cuddHashTableInsert</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddHashTableQuit"><b>cuddHashTableQuit</b></a>(
  DdHashTable * <b>hash</b> <i></i>
)
</pre>
<dd> Shuts down a hash table, dereferencing all the values.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddHashTableInit">cuddHashTableInit</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddHeapProfile"><b>cuddHeapProfile</b></a>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Prints to the manager's stdout the number of live nodes for each level of the DD heap that contains at least one live node. It also prints a summary containing: <ul> <li> total number of tables; <li> number of tables with live nodes; <li> table with the largest number of live nodes; <li> number of nodes in that table. </ul> If more than one table contains the maximum number of live nodes, only the one of lowest index is reported. Returns 1 in case of success and 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
 <i></i>
<a name="cuddIZ"><b>cuddIZ</b></a>(
   <b>dd</b>, <i></i>
   <b>index</b> <i></i>
)
</pre>
<dd> Finds the current position of ZDD variable index in the order. This macro duplicates the functionality of Cudd_ReadPermZdd, but it does not check for out-of-bounds indices and it is more efficient.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPermZdd">Cudd_ReadPermZdd</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddInitCache"><b>cuddInitCache</b></a>(
  DdManager * <b>unique</b>, <i>unique table</i>
  unsigned int  <b>cacheSize</b>, <i>initial size of the cache</i>
  unsigned int  <b>maxCacheSize</b> <i>cache size beyond which no resizing occurs</i>
)
</pre>
<dd> Initializes the computed table. It is called by Cudd_Init. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Init">Cudd_Init</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddInitInteract"><b>cuddInitInteract</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Initializes the interaction matrix. The interaction matrix is implemented as a bit vector storing the upper triangle of the symmetric interaction matrix. The bit vector is kept in an array of long integers. The computation is based on a series of depth-first searches, one for each root of the DAG. Two flags are needed: The local visited flag uses the LSB of the then pointer. The global visited flag uses the LSB of the next pointer. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddInitLinear"><b>cuddInitLinear</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Initializes the linear transform matrix. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
DdManager * <i></i>
<a name="cuddInitTable"><b>cuddInitTable</b></a>(
  unsigned int  <b>numVars</b>, <i>Initial number of BDD variables (and subtables)</i>
  unsigned int  <b>numVarsZ</b>, <i>Initial number of ZDD variables (and subtables)</i>
  unsigned int  <b>numSlots</b>, <i>Initial size of the BDD subtables</i>
  unsigned int  <b>looseUpTo</b> <i>Limit for fast table growth</i>
)
</pre>
<dd> Creates and initializes the unique table. Returns a pointer to the table if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Init">Cudd_Init</a>
<a href="cuddAllDet.html#cuddFreeTable">cuddFreeTable</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddInsertSubtables"><b>cuddInsertSubtables</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>n</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Inserts n new subtables in a unique table at level. The number n should be positive, and level should be an existing level. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddDestroySubtables">cuddDestroySubtables</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddIsConstant"><b>cuddIsConstant</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns 1 if the node is a constant node (rather than an internal node). All constant nodes have the same index (CUDD_CONST_INDEX). The pointer passed to cuddIsConstant must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_IsConstant">Cudd_IsConstant</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddIsInDeathRow"><b>cuddIsInDeathRow</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Checks whether a node is in the death row. Returns the position of the first occurrence if the node is present; -1 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="cuddAllDet.html#cuddClearDeathRow">cuddClearDeathRow</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddI"><b>cuddI</b></a>(
   <b>dd</b>, <i></i>
   <b>index</b> <i></i>
)
</pre>
<dd> Finds the current position of variable index in the order. This macro duplicates the functionality of Cudd_ReadPerm, but it does not check for out-of-bounds indices and it is more efficient.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddLevelQueueDequeue"><b>cuddLevelQueueDequeue</b></a>(
  DdLevelQueue * <b>queue</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Remove an item from the front of a level queue.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
</code>

<dt><pre>
void * <i></i>
<a name="cuddLevelQueueEnqueue"><b>cuddLevelQueueEnqueue</b></a>(
  DdLevelQueue * <b>queue</b>, <i>level queue</i>
  void * <b>key</b>, <i>key to be enqueued</i>
  int  <b>level</b> <i>level at which to insert</i>
)
</pre>
<dd> Inserts a new key in a level queue. A new entry is created in the queue only if the node is not already enqueued. Returns a pointer to the queue item if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddLevelQueueInit">cuddLevelQueueInit</a>
<a href="cuddAllDet.html#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
</code>

<dt><pre>
DdLevelQueue * <i></i>
<a name="cuddLevelQueueInit"><b>cuddLevelQueueInit</b></a>(
  int  <b>levels</b>, <i>number of levels</i>
  int  <b>itemSize</b>, <i>size of the item</i>
  int  <b>numBuckets</b> <i>initial number of hash buckets</i>
)
</pre>
<dd> Initializes a level queue. A level queue is a queue where inserts are based on the levels of the nodes. Within each level the policy is FIFO. Level queues are useful in traversing a BDD top-down. Queue items are kept in a free list when dequeued for efficiency. Returns a pointer to the new queue if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddLevelQueueQuit">cuddLevelQueueQuit</a>
<a href="cuddAllDet.html#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
<a href="cuddAllDet.html#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddLevelQueueQuit"><b>cuddLevelQueueQuit</b></a>(
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Shuts down a level queue and releases all the associated memory.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddLevelQueueInit">cuddLevelQueueInit</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddLinearAndSifting"><b>cuddLinearAndSifting</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> BDD reduction based on combination of sifting and linear transformations. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique table. <li> Sift the variable up and down, remembering each time the total size of the DD heap. At each position, linear transformation of the two adjacent variables is tried and is accepted if it reduces the size of the DD. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. </ol> Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddLinearInPlace"><b>cuddLinearInPlace</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Linearly combines two adjacent variables. Specifically, replaces the top variable with the exclusive nor of the two variables. It assumes that no dead nodes are present on entry to this procedure. The procedure then guarantees that no dead nodes will be present when it terminates. cuddLinearInPlace assumes that x &lt; y. Returns the number of keys in the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The two subtables corrresponding to variables x and y are modified. The global counters of the unique table are also affected.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddSwapInPlace">cuddSwapInPlace</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddLocalCacheClearAll"><b>cuddLocalCacheClearAll</b></a>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Clears the local caches of a manager. Used before reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddLocalCacheClearDead"><b>cuddLocalCacheClearDead</b></a>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Clears the dead entries of the local caches of a manager. Used during garbage collection.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdLocalCache * <i></i>
<a name="cuddLocalCacheInit"><b>cuddLocalCacheInit</b></a>(
  DdManager * <b>manager</b>, <i>manager</i>
  unsigned int  <b>keySize</b>, <i>size of the key (number of operands)</i>
  unsigned int  <b>cacheSize</b>, <i>Initial size of the cache</i>
  unsigned int  <b>maxCacheSize</b> <i>Size of the cache beyond which no resizing occurs</i>
)
</pre>
<dd> Initializes a computed table. Returns a pointer the the new local cache in case of success; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddInitCache">cuddInitCache</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddLocalCacheInsert"><b>cuddLocalCacheInsert</b></a>(
  DdLocalCache * <b>cache</b>, <i></i>
  DdNodePtr * <b>key</b>, <i></i>
  DdNode * <b>value</b> <i></i>
)
</pre>
<dd> Inserts a result in a local cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddLocalCacheLookup"><b>cuddLocalCacheLookup</b></a>(
  DdLocalCache * <b>cache</b>, <i></i>
  DdNodePtr * <b>key</b> <i></i>
)
</pre>
<dd> Looks up in a local cache. Returns the result if found; it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddLocalCacheProfile"><b>cuddLocalCacheProfile</b></a>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Computes and prints a profile of a local cache usage. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddLocalCacheQuit"><b>cuddLocalCacheQuit</b></a>(
  DdLocalCache * <b>cache</b> <i>cache to be shut down</i>
)
</pre>
<dd> Initializes the computed table. It is called by Cudd_Init. Returns a pointer the the new local cache in case of success; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddLocalCacheInit">cuddLocalCacheInit</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="cuddMakeBddFromZddCover"><b>cuddMakeBddFromZddCover</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Converts a ZDD cover to a BDD graph. If successful, it returns a BDD node, otherwise it returns NULL. It is a recursive algorithm as the following. First computes 3 cofactors of a ZDD cover; f1, f0 and fd. Second, compute BDDs(b1, b0 and bd) of f1, f0 and fd. Third, compute T=b1+bd and E=b0+bd. Fourth, compute ITE(v,T,E) where v is the variable which has the index of the top node of the ZDD cover. In this case, since the index of v can be larger than either one of T or one of E, cuddUniqueInterIVO is called, here IVO stands for independent variable ordering.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_MakeBddFromZddCover">Cudd_MakeBddFromZddCover</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddNextHigh"><b>cuddNextHigh</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a larger index. Returns the index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddNextLow">cuddNextLow</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddNextLow"><b>cuddNextLow</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a smaller index. Returns the index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddNextHigh">cuddNextHigh</a>
</code>

<dt><pre>
DdNodePtr * <i></i>
<a name="cuddNodeArray"><b>cuddNodeArray</b></a>(
  DdNode * <b>f</b>, <i></i>
  int * <b>n</b> <i></i>
)
</pre>
<dd> Traverses the DD f and collects all its nodes in an array. The caller should free the array returned by cuddNodeArray. Returns a pointer to the array of nodes in case of success; NULL otherwise. The nodes are collected in reverse topological order, so that a node is always preceded in the array by all its descendants.
<p>

<dd> <b>Side Effects</b> The number of nodes is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_FirstNode">Cudd_FirstNode</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddPrintNode"><b>cuddPrintNode</b></a>(
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints out information on a node.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddPrintVarGroups"><b>cuddPrintVarGroups</b></a>(
  DdManager * <b>dd</b>, <i>manager</i>
  MtrNode * <b>root</b>, <i>root of the group tree</i>
  int  <b>zdd</b>, <i>0: BDD; 1: ZDD</i>
  int  <b>silent</b> <i>flag to check tree syntax only</i>
)
</pre>
<dd> Prints the variable groups as a parenthesized list. For each group the level range that it represents is printed. After each group, the group's flags are printed, preceded by a `|'. For each flag (except MTR_TERMINAL) a character is printed. <ul> <li>F: MTR_FIXED <li>N: MTR_NEWNODE <li>S: MTR_SOFT </ul> The second argument, silent, if different from 0, causes Cudd_PrintVarGroups to only check the syntax of the group tree.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddP"><b>cuddP</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Prints a DD to the standard output. One line per node is printed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_PrintDebug">Cudd_PrintDebug</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddReclaimZdd"><b>cuddReclaimZdd</b></a>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Brings children of a dead ZDD node back.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddReclaim">cuddReclaim</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddReclaim"><b>cuddReclaim</b></a>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Brings children of a dead node back.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddReclaimZdd">cuddReclaimZdd</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddRef"><b>cuddRef</b></a>(
   <b>n</b> <i></i>
)
</pre>
<dd> Increases the reference count of a node, if it is not saturated. This being a macro, it is faster than Cudd_Ref, but it cannot be used in constructs like cuddRef(a = b()).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_Ref">Cudd_Ref</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddRehash"><b>cuddRehash</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Doubles the size of a unique subtable and rehashes its contents.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddRemapUnderApprox"><b>cuddRemapUnderApprox</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Applies the remapping underappoximation algorithm. Proceeds in three phases: <ul> <li> collect information on each node in the BDD; this is done via DFS. <li> traverse the BDD in top-down fashion and compute for each node whether remapping increases density. <li> traverse the BDD via DFS and actually perform the elimination. </ul> Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_RemapUnderApprox">Cudd_RemapUnderApprox</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddResizeLinear"><b>cuddResizeLinear</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Resizes the linear transform matrix. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
int <i></i>
<a name="cuddResizeTableZdd"><b>cuddResizeTableZdd</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Increases the number of ZDD subtables in a unique table so that it meets or exceeds index. When new ZDD variables are created, it is possible to preserve the functions unchanged, or it is possible to preserve the covers unchanged, but not both. cuddResizeTableZdd preserves the covers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddResizeTable">ddResizeTable</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddSatDec"><b>cuddSatDec</b></a>(
   <b>x</b> <i></i>
)
</pre>
<dd> Saturating decrement operator.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddSatInc">cuddSatInc</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddSatInc"><b>cuddSatInc</b></a>(
   <b>x</b> <i></i>
)
</pre>
<dd> Saturating increment operator.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddSatDec">cuddSatDec</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddSetInteract"><b>cuddSetInteract</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Given a pair of variables 0 <= x < y < table->size, sets the corresponding bit of the interaction matrix to 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddShrinkDeathRow"><b>cuddShrinkDeathRow</b></a>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Shrinks the death row by a factor of four.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddClearDeathRow">cuddClearDeathRow</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddShrinkSubtable"><b>cuddShrinkSubtable</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Shrinks a subtable.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddRehash">cuddRehash</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddSifting"><b>cuddSifting</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of Rudell's sifting algorithm. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique table. <li> Sift the variable up and down, remembering each time the total size of the DD heap. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. </ol> Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
void <i></i>
<a name="cuddSlowTableGrowth"><b>cuddSlowTableGrowth</b></a>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Adjusts parameters of a table to slow down its growth.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddSolveEqnRecur"><b>cuddSolveEqnRecur</b></a>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode * <b>Y</b>, <i>the cube of remaining y variables</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int  <b>n</b>, <i>number of unknowns</i>
  int * <b>yIndex</b>, <i>array holding the y variable indices</i>
  int  <b>i</b> <i>level of recursion</i>
)
</pre>
<dd> Implements the recursive step of Cudd_SolveEqn. Returns NULL if the intermediate solution blows up or reordering occurs. The parametric solutions are stored in the array G.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SolveEqn">Cudd_SolveEqn</a>
<a href="cuddAllDet.html#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<dt><pre>
DdNode* <i></i>
<a name="cuddSplitSetRecur"><b>cuddSplitSetRecur</b></a>(
  DdManager * <b>manager</b>, <i></i>
  st_table * <b>mtable</b>, <i></i>
  int * <b>varSeen</b>, <i></i>
  DdNode * <b>p</b>, <i></i>
  double  <b>n</b>, <i></i>
  double  <b>max</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_SplitSet. The procedure recursively traverses the BDD and checks to see if any node satisfies the minterm requirements as specified by 'n'. At any node X, n is compared to the number of minterms in the onset of X's children. If either of the child nodes have exactly n minterms, then that node is returned; else, if n is greater than the onset of one of the child nodes, that node is retained and the difference in the number of minterms is extracted from the other child. In case n minterms can be extracted from constant 1, the algorithm returns the result with at most log(n) nodes.
<p>

<dd> <b>Side Effects</b> The array 'varSeen' is updated at every recursive call to set the variables traversed by the procedure.
<p>

<dt><pre>
enum st_retval <i></i>
<a name="cuddStCountfree"><b>cuddStCountfree</b></a>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory used to store the minterm counts recorded in the visited table. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddSubsetHeavyBranch"><b>cuddSubsetHeavyBranch</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b> <i>threshold size for the subset</i>
)
</pre>
<dd> Here a subset BDD is built by throwing away one of the children. Starting at root, annotate each node with the number of minterms (in terms of the total number of variables specified - numVars), number of nodes taken by the DAG rooted at this node and number of additional nodes taken by the child that has the lesser minterms. The child with the lower number of minterms is thrown away and a dyanmic count of the nodes of the subset is kept. Once the threshold is reached the subset is returned to the calling procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddSubsetShortPaths"><b>cuddSubsetShortPaths</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>total number of variables in consideration</i>
  int  <b>threshold</b>, <i>maximum number of nodes allowed in the subset</i>
  int  <b>hardlimit</b> <i>flag determining whether thershold should be respected strictly</i>
)
</pre>
<dd> The outermost procedure to return a subset of the given BDD with the largest cubes. The path lengths are calculated, the maximum allowable path length is determined and the number of nodes of this path length that can be used to build a subset. If the threshold is larger than the size of the original BDD, the original BDD is returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddSwapInPlace"><b>cuddSwapInPlace</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps two adjacent variables. It assumes that no dead nodes are present on entry to this procedure. The procedure then guarantees that no dead nodes will be present when it terminates. cuddSwapInPlace assumes that x &lt; y. Returns the number of keys in the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddSwapping"><b>cuddSwapping</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  Cudd_ReorderingType  <b>heuristic</b> <i></i>
)
</pre>
<dd> Implementation of Plessier's algorithm that reorders variables by a sequence of (non-adjacent) swaps. <ol> <li> Select two variables (RANDOM or HEURISTIC). <li> Permute these variables. <li> If the nodes have decreased accept the permutation. <li> Otherwise reconstruct the original heap. <li> Loop. </ol> Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddSymmCheck"><b>cuddSymmCheck</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for symmetry of x and y. Ignores projection functions, unless they are isolated. Returns 1 in case of symmetry; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddSymmSiftingConv"><b>cuddSymmSiftingConv</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting to convergence algorithm. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique subtable. <li> Sift the variable up and down, remembering each time the total size of the DD heap and grouping variables that are symmetric. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. <li> Repeat 1-4 until no further improvement. </ol> Returns 1 plus the number of symmetric variables if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddSymmSifting">cuddSymmSifting</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddSymmSifting"><b>cuddSymmSifting</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting algorithm. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique subtable. <li> Sift the variable up and down, remembering each time the total size of the DD heap and grouping variables that are symmetric. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. </ol> Returns 1 plus the number of symmetric variables if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddSymmSiftingConv">cuddSymmSiftingConv</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddTestInteract"><b>cuddTestInteract</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Given a pair of variables 0 <= x < y < table->size, tests whether the corresponding bit of the interaction matrix is 1. Returns the value of the bit.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddTimesInDeathRow"><b>cuddTimesInDeathRow</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Counts how many times a node is in the death row.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="cuddAllDet.html#cuddClearDeathRow">cuddClearDeathRow</a>
<a href="cuddAllDet.html#cuddIsInDeathRow">cuddIsInDeathRow</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddTreeSifting"><b>cuddTreeSifting</b></a>(
  DdManager * <b>table</b>, <i>DD table</i>
  Cudd_ReorderingType  <b>method</b> <i>reordering method for the groups of leaves</i>
)
</pre>
<dd> Tree sifting algorithm. Assumes that a tree representing a group hierarchy is passed as a parameter. It then reorders each group in postorder fashion by calling ddTreeSiftingAux. Assumes that no dead nodes are present. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
 <i></i>
<a name="cuddT"><b>cuddT</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the then child of an internal node. If <code>node</code> is a constant node, the result is unpredictable. The pointer passed to cuddT must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_T">Cudd_T</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddUnderApprox"><b>cuddUnderApprox</b></a>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Applies Tom Shiple's underappoximation algorithm. Proceeds in three phases: <ul> <li> collect information on each node in the BDD; this is done via DFS. <li> traverse the BDD in top-down fashion and compute for each node whether its elimination increases density. <li> traverse the BDD via DFS and actually perform the elimination. </ul> Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_UnderApprox">Cudd_UnderApprox</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddUniqueConst"><b>cuddUniqueConst</b></a>(
  DdManager * <b>unique</b>, <i></i>
  CUDD_VALUE_TYPE  <b>value</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of a constant node. If it does not exist, it creates a new one. Does not modify the reference count of whatever is returned. A newly created internal node comes back with a reference count 0. Returns a pointer to the new node.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddUniqueInterIVO"><b>cuddUniqueInterIVO</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInter that is independent of variable ordering (IVO). This function does not require parameter index to precede the indices of the top nodes of T and E in the variable order. Returns a pointer to the result node under normal conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddUniqueInter">cuddUniqueInter</a>
<a href="cuddAllDet.html#Cudd_MakeBddFromZddCover">Cudd_MakeBddFromZddCover</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddUniqueInterZdd"><b>cuddUniqueInterZdd</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal ZDD node. If it does not exist, it creates a new one. Does not modify the reference count of whatever is returned. A newly created internal node comes back with a reference count 0. For a newly created node, increments the reference counts of what T and E point to. Returns a pointer to the new node if successful; NULL if memory is exhausted or if reordering took place.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddUniqueInter">cuddUniqueInter</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddUniqueInter"><b>cuddUniqueInter</b></a>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal node. If it does not exist, it creates a new one. Does not modify the reference count of whatever is returned. A newly created internal node comes back with a reference count 0. For a newly created node, increments the reference counts of what T and E point to. Returns a pointer to the new node if successful; NULL if memory is exhausted or if reordering took place.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddUniqueInterZdd">cuddUniqueInterZdd</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddUpdateInteractionMatrix"><b>cuddUpdateInteractionMatrix</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>xindex</b>, <i></i>
  int  <b>yindex</b> <i></i>
)
</pre>
<dd> Updates the interaction matrix.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddVerifySol"><b>cuddVerifySol</b></a>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int * <b>yIndex</b>, <i>array holding the y variable indices</i>
  int  <b>n</b> <i>number of unknowns</i>
)
</pre>
<dd> Implements the recursive step of Cudd_VerifySol.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<dt><pre>
 <i></i>
<a name="cuddV"><b>cuddV</b></a>(
   <b>node</b> <i></i>
)
</pre>
<dd> Returns the value of a constant node. If <code>node</code> is an internal node, the result is unpredictable. The pointer passed to cuddV must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_V">Cudd_V</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddWindowReorder"><b>cuddWindowReorder</b></a>(
  DdManager * <b>table</b>, <i>DD table</i>
  int  <b>low</b>, <i>lowest index to reorder</i>
  int  <b>high</b>, <i>highest index to reorder</i>
  Cudd_ReorderingType  <b>submethod</b> <i>window reordering option</i>
)
</pre>
<dd> Reorders by applying the method of the sliding window. Tries all possible permutations to the variables in a window that slides from low to high. The size of the window is determined by submethod. Assumes that no dead nodes are present. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddAlignToBdd"><b>cuddZddAlignToBdd</b></a>(
  DdManager * <b>table</b> <i>DD manager</i>
)
</pre>
<dd> Reorders ZDD variables according to the order of the BDD variables. This function can be called at the end of BDD reordering to insure that the order of the ZDD variables is consistent with the order of the BDD variables. The number of ZDD variables must be a multiple of the number of BDD variables. Let <code>M</code> be the ratio of the two numbers. cuddZddAlignToBdd then considers the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> as corresponding to BDD variable <code>i</code>. This function should be normally called from Cudd_ReduceHeap, which clears the cache. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the ZDD variable order for all diagrams and performs garbage collection of the ZDD unique table.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddShuffleHeap">Cudd_zddShuffleHeap</a>
<a href="cuddAllDet.html#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddChangeAux"><b>cuddZddChangeAux</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>zvar</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddChange.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddChange"><b>cuddZddChange</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Substitutes a variable with its complement in a ZDD. returns a pointer to the result if successful; NULL otherwise. cuddZddChange performs the same function as Cudd_zddChange, but does not restart if reordering has taken place. Therefore it can be called from within a recursive procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddChange">Cudd_zddChange</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddComplement"><b>cuddZddComplement</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Computes the complement of a ZDD node. So far, since we couldn't find a direct way to get the complement of a ZDD cover, we first convert a ZDD cover to a BDD, then make the complement of the ZDD cover from the complement of the BDD node by using ISOP.
<p>

<dd> <b>Side Effects</b> The result depends on current variable order.
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddDiff"><b>cuddZddDiff</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDiff.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddDivideF"><b>cuddZddDivideF</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDivideF.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddDivideF">Cudd_zddDivideF</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddDivide"><b>cuddZddDivide</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDivide.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddDivide">Cudd_zddDivide</a>
</code>

<dt><pre>
void <i></i>
<a name="cuddZddFreeUniv"><b>cuddZddFreeUniv</b></a>(
  DdManager * <b>zdd</b> <i></i>
)
</pre>
<dd> Frees the ZDD universe.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddInitUniv">cuddZddInitUniv</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddGetCofactors2"><b>cuddZddGetCofactors2</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>v</b>, <i></i>
  DdNode ** <b>f1</b>, <i></i>
  DdNode ** <b>f0</b> <i></i>
)
</pre>
<dd> Computes the two-way decomposition of f w.r.t. v.
<p>

<dd> <b>Side Effects</b> The results are returned in f1 and f0.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddGetCofactors3">cuddZddGetCofactors3</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddGetCofactors3"><b>cuddZddGetCofactors3</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>v</b>, <i></i>
  DdNode ** <b>f1</b>, <i></i>
  DdNode ** <b>f0</b>, <i></i>
  DdNode ** <b>fd</b> <i></i>
)
</pre>
<dd> Computes the three-way decomposition of function f (represented by a ZDD) wit respect to variable v.
<p>

<dd> <b>Side Effects</b> The results are returned in f1, f0, and fd.
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddGetCofactors2">cuddZddGetCofactors2</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddGetNegVarIndex"><b>cuddZddGetNegVarIndex</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the index of negative ZDD variable.
<p>

<dt><pre>
int <i></i>
<a name="cuddZddGetNegVarLevel"><b>cuddZddGetNegVarLevel</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the level of negative ZDD variable.
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddGetNodeIVO"><b>cuddZddGetNodeIVO</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInterZdd that is independent of variable ordering (IVO). This function does not require parameter index to precede the indices of the top nodes of g and h in the variable order. Returns a pointer to the result node under normal conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddGetNode">cuddZddGetNode</a>
<a href="cuddAllDet.html#cuddZddIsop">cuddZddIsop</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddGetNode"><b>cuddZddGetNode</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  int  <b>id</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInterZdd, which applies the ZDD reduction rule. Returns a pointer to the result node under normal conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddUniqueInterZdd">cuddUniqueInterZdd</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddGetPosVarIndex"><b>cuddZddGetPosVarIndex</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the index of positive ZDD variable.
<p>

<dt><pre>
int <i></i>
<a name="cuddZddGetPosVarLevel"><b>cuddZddGetPosVarLevel</b></a>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the level of positive ZDD variable.
<p>

<dt><pre>
int <i></i>
<a name="cuddZddInitUniv"><b>cuddZddInitUniv</b></a>(
  DdManager * <b>zdd</b> <i></i>
)
</pre>
<dd> Initializes the ZDD universe. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddFreeUniv">cuddZddFreeUniv</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddIntersect"><b>cuddZddIntersect</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIntersect.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddIsop"><b>cuddZddIsop</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b>, <i></i>
  DdNode ** <b>zdd_I</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIsop.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddIsop">Cudd_zddIsop</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddIte"><b>cuddZddIte</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIte.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddLinearSifting"><b>cuddZddLinearSifting</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of the linear sifting algorithm for ZDDs. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique table. <li> Sift the variable up and down and applies the XOR transformation, remembering each time the total size of the DD heap. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. </ol> Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddNextHigh"><b>cuddZddNextHigh</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a larger index. Returns the index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddNextLow"><b>cuddZddNextLow</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a smaller index. Returns the index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddProduct"><b>cuddZddProduct</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddProduct.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddProduct">Cudd_zddProduct</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddP"><b>cuddZddP</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Prints a ZDD to the standard output. One line per node is printed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddPrintDebug">Cudd_zddPrintDebug</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddSifting"><b>cuddZddSifting</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of Rudell's sifting algorithm. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique table. <li> Sift the variable up and down, remembering each time the total size of the DD heap. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. </ol> Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddSubset0"><b>cuddZddSubset0</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the negative cofactor of a ZDD w.r.t. a variable. In terms of combinations, the result is the set of all combinations in which the variable is negated. Returns a pointer to the result if successful; NULL otherwise. cuddZddSubset0 performs the same function as Cudd_zddSubset0, but does not restart if reordering has taken place. Therefore it can be called from within a recursive procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddSubset1">cuddZddSubset1</a>
<a href="cuddAllDet.html#Cudd_zddSubset0">Cudd_zddSubset0</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddSubset1"><b>cuddZddSubset1</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the positive cofactor of a ZDD w.r.t. a variable. In terms of combinations, the result is the set of all combinations in which the variable is asserted. Returns a pointer to the result if successful; NULL otherwise. cuddZddSubset1 performs the same function as Cudd_zddSubset1, but does not restart if reordering has taken place. Therefore it can be called from within a recursive procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddSubset0">cuddZddSubset0</a>
<a href="cuddAllDet.html#Cudd_zddSubset1">Cudd_zddSubset1</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddSwapInPlace"><b>cuddZddSwapInPlace</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps two adjacent variables. It assumes that no dead nodes are present on entry to this procedure. The procedure then guarantees that no dead nodes will be present when it terminates. cuddZddSwapInPlace assumes that x &lt; y. Returns the number of keys in the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddSwapping"><b>cuddZddSwapping</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  Cudd_ReorderingType  <b>heuristic</b> <i></i>
)
</pre>
<dd> Implementation of Plessier's algorithm that reorders variables by a sequence of (non-adjacent) swaps. <ol> <li> Select two variables (RANDOM or HEURISTIC). <li> Permute these variables. <li> If the nodes have decreased accept the permutation. <li> Otherwise reconstruct the original heap. <li> Loop. </ol> Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddSymmCheck"><b>cuddZddSymmCheck</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for symmetry of x and y. Ignores projection functions, unless they are isolated. Returns 1 in case of symmetry; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddSymmSiftingConv"><b>cuddZddSymmSiftingConv</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting to convergence algorithm for ZDDs. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique subtable. <li> Sift the variable up and down, remembering each time the total size of the ZDD heap and grouping variables that are symmetric. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. <li> Repeat 1-4 until no further improvement. </ol> Returns 1 plus the number of symmetric variables if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddSymmSifting">cuddZddSymmSifting</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddSymmSifting"><b>cuddZddSymmSifting</b></a>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting algorithm. Assumes that no dead nodes are present. <ol> <li> Order all the variables according to the number of entries in each unique subtable. <li> Sift the variable up and down, remembering each time the total size of the ZDD heap and grouping variables that are symmetric. <li> Select the best permutation. <li> Repeat 3 and 4 for all variables. </ol> Returns 1 plus the number of symmetric variables if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#cuddZddSymmSiftingConv">cuddZddSymmSiftingConv</a>
</code>

<dt><pre>
int <i></i>
<a name="cuddZddTreeSifting"><b>cuddZddTreeSifting</b></a>(
  DdManager * <b>table</b>, <i>DD table</i>
  Cudd_ReorderingType  <b>method</b> <i>reordering method for the groups of leaves</i>
)
</pre>
<dd> Tree sifting algorithm for ZDDs. Assumes that a tree representing a group hierarchy is passed as a parameter. It then reorders each group in postorder fashion by calling zddTreeSiftingAux. Assumes that no dead nodes are present. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddUnateProduct"><b>cuddZddUnateProduct</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddUnateProduct.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddUnateProduct">Cudd_zddUnateProduct</a>
</code>

<dt><pre>
DdNode * <i></i>
<a name="cuddZddUnion"><b>cuddZddUnion</b></a>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddUnion.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
int <i></i>
<a name="cuddZddUniqueCompare"><b>cuddZddUniqueCompare</b></a>(
  int * <b>ptr_x</b>, <i></i>
  int * <b>ptr_y</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the variables according to the number of keys in the subtables. Returns the difference in number of keys between the two variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddWeakDivF"><b>cuddZddWeakDivF</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddWeakDivF.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddWeakDivF">Cudd_zddWeakDivF</a>
</code>

<dt><pre>
DdNode	* <i></i>
<a name="cuddZddWeakDiv"><b>cuddZddWeakDiv</b></a>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddWeakDiv.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="cuddAllDet.html#Cudd_zddWeakDiv">Cudd_zddWeakDiv</a>
</code>

<dt><pre>
 <i></i>
<a name="ddAbs"><b>ddAbs</b></a>(
   <b>x</b> <i></i>
)
</pre>
<dd> Computes the absolute value of a number.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
 <i></i>
<a name="ddCHash2"><b>ddCHash2</b></a>(
   <b>o</b>, <i></i>
   <b>f</b>, <i></i>
   <b>g</b>, <i></i>
   <b>s</b> <i></i>
)
</pre>
<dd> Hash function for the cache for functions with two operands.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddHash">ddHash</a>
<a href="ddAllDet.html#ddCHash">ddCHash</a>
</code>

<dt><pre>
 <i></i>
<a name="ddCHash"><b>ddCHash</b></a>(
   <b>o</b>, <i></i>
   <b>f</b>, <i></i>
   <b>g</b>, <i></i>
   <b>h</b>, <i></i>
   <b>s</b> <i></i>
)
</pre>
<dd> Hash function for the cache.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddHash">ddHash</a>
<a href="ddAllDet.html#ddCHash2">ddCHash2</a>
</code>

<dt><pre>
 <i></i>
<a name="ddEqualVal"><b>ddEqualVal</b></a>(
   <b>x</b>, <i></i>
   <b>y</b>, <i></i>
   <b>e</b> <i></i>
)
</pre>
<dd> Returns 1 if the absolute value of the difference of the two arguments x and y is less than e.
<p>

<dd> <b>Side Effects</b> none
<p>

<dt><pre>
 <i></i>
<a name="ddHash"><b>ddHash</b></a>(
   <b>f</b>, <i></i>
   <b>g</b>, <i></i>
   <b>s</b> <i></i>
)
</pre>
<dd> Hash function for the unique table.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddCHash">ddCHash</a>
<a href="ddAllDet.html#ddCHash2">ddCHash2</a>
</code>

<dt><pre>
 <i></i>
<a name="ddLCHash2"><b>ddLCHash2</b></a>(
   <b>f</b>, <i></i>
   <b>g</b>, <i></i>
   <b>shift</b> <i></i>
)
</pre>
<dd> Computes hash function for keys of two operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddLCHash3">ddLCHash3</a>
<a href="ddAllDet.html#ddLCHash">ddLCHash</a>
</code>

<dt><pre>
 <i></i>
<a name="ddLCHash3"><b>ddLCHash3</b></a>(
   <b>f</b>, <i></i>
   <b>g</b>, <i></i>
   <b>h</b>, <i></i>
   <b>shift</b> <i></i>
)
</pre>
<dd> Computes hash function for keys of three operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddLCHash2">ddLCHash2</a>
<a href="ddAllDet.html#ddLCHash">ddLCHash</a>
</code>

<dt><pre>
 <i></i>
<a name="ddMax"><b>ddMax</b></a>(
   <b>x</b>, <i></i>
   <b>y</b> <i></i>
)
</pre>
<dd> Computes the maximum of two numbers.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddMin">ddMin</a>
</code>

<dt><pre>
 <i></i>
<a name="ddMin"><b>ddMin</b></a>(
   <b>x</b>, <i></i>
   <b>y</b> <i></i>
)
</pre>
<dd> Computes the minimum of two numbers.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="ddAllDet.html#ddMax">ddMax</a>
</code>

<dt><pre>
 <i></i>
<a name="lqHash"><b>lqHash</b></a>(
   <b>key</b>, <i></i>
   <b>shift</b> <i></i>
)
</pre>
<dd> Hash function for the table of a level queue.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="hashAllDet.html#hashInsert">hashInsert</a>
<a href="hashAllDet.html#hashLookup">hashLookup</a>
<a href="hashAllDet.html#hashDelete">hashDelete</a>
</code>

<dt><pre>
 <i></i>
<a name="statLine"><b>statLine</b></a>(
   <b>dd</b> <i></i>
)
</pre>
<dd> Outputs a line of stats if DD_COUNT and DD_STATS are defined. Increments the number of recursive calls if DD_COUNT is defined.
<p>

<dd> <b>Side Effects</b> None
<p>


</dl>

<hr>

Generated automatically by <code>extdoc</code> on 20040206

</body></html>
