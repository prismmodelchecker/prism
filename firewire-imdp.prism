// integer semantics version of abstract firewire protocol
// gxn 23/05/2001

mdp

// wire delay
const int delay=1;

// probability of choosing fast and slow
const double fast=0.5;
const double slow = 1-fast;
const double e = 0.05;

// largest constant the clock of the system is compared to
const int kx = 167;

module abstract_firewire
	
	// clock 
	x : [0..kx+1];
	
	// local state
	s : [0..9];
	// 0 -start_start
	// 1 -fast_start
	// 2 -start_fast
	// 3 -start_slow
	// 4 -slow_start
	// 5 -fast_fast
	// 6 -fast_slow
	// 7 -slow_fast
	// 8 -slow_slow
	// 9 -done
	
	// initial state
	[time] s=0 & x<delay -> (x'=min(x+1,kx+1));
	[round1] s=0 -> [fast-e,fast+e] : (s'=1) + [slow-e,slow+e] : (s'=4);
	[round2] s=0 -> [fast-e,fast+e] : (s'=2) + [slow-e,slow+e] : (s'=3);
	// fast_start
	[time] s=1 & x<delay -> (x'=min(x+1,kx+1));
	[tfs] s=1 -> fast : (s'=5) & (x'=0) + slow : (s'=6) & (x'=0);
	// start_fast
	[time] s=2 & x<delay -> (x'=min(x+1,kx+1));
	[tsf] s=2 -> [fast-e,fast+e] : (s'=5) & (x'=0) + [slow-e,slow+e] : (s'=7) & (x'=0);
	// start_slow
	[time] s=3 & x<delay -> (x'=min(x+1,kx+1));
	[tss] s=3 -> fast : (s'=6) & (x'=0) + [slow-e,slow+e] : (s'=8) & (x'=0);
	// slow_start
	[time] s=4 & x<delay -> (x'=min(x+1,kx+1));
	[tsls] s=4 -> [fast-e,fast+e] : (s'=7) & (x'=0) +[slow-e,slow+e]: (s'=8) & (x'=0);
	// fast_fast
	[time] s=5 & (x<85) -> (x'=min(x+1,kx+1));
	[tff] s=5 & (x>=76) -> (s'=0) & (x'=0);
	[tff2] s=5 & (x>=76-delay) -> (s'=9) & (x'=0);
	// fast_slow
	[time] s=6 & x<167 -> (x'=min(x+1,kx+1));
	[tfs] s=6 & x>=159-delay -> (s'=9) & (x'=0);
	// slow_fast
	[time] s=7 & x<167 -> (x'=min(x+1,kx+1));
	[tsf] s=7 & x>=159-delay -> (s'=9) & (x'=0);
	// slow_slow
	[time] s=8 & x<167 -> (x'=min(x+1,kx+1));
	[tss] s=8 & x>=159 -> (s'=0) & (x'=0);
	[tss] s=8 & x>=159-delay -> (s'=9) & (x'=0);
	// done
	[done] s=9 -> 1:(s'=s);
	
endmodule

//reward structures
// time
rewards
	[time] true : 1;
endrewards
// number of rounds
//rewards "rounds"
//	[round] true : 1;
//endrewards
label "goal" = (s=9);